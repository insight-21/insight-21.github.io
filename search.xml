<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Acwing算法进阶指南 0x00 &amp; 0x01 打卡 题解</title>
    <url>/archives/1505869346/</url>
    <content><![CDATA[<p>学习《算法竞赛进阶指南》中的0x00 &amp; 0x01章<br>包括国内大公司笔试以及noip、acm、蓝桥杯等比赛涉及的绝大部分知识点</p>
<a id="more"></a>

<p><a href="https://www.acwing.com/user/myspace/index/34956/" target="_blank" rel="noopener">欢迎来Acwing围观我</a><br>点击标题，进入题目。</p>
<h2 id="Acwing-132-小组队列"><a href="#Acwing-132-小组队列" class="headerlink" title="Acwing 132. 小组队列"></a><a href="https://www.acwing.com/problem/content/134/" target="_blank" rel="noopener">Acwing 132. 小组队列</a></h2><p>开始队列小节</p>
<h3 id="队列数组-模拟"><a href="#队列数组-模拟" class="headerlink" title="队列数组 + 模拟"></a>队列数组 + 模拟</h3><p>由于题目要求出队和入队在常数时间内, 因此考虑把所有队伍的编号按照顺序抽取成一个队列, 再把每个队伍细化成一个队列, 也就是一个队列数组<br>为了快速找到当前队员的队伍号, 再用哈希的方式, 以队员编号为数组下标, 队伍号为数组值<br>剩下的就是模拟了, 要注意的是, 当出队后队伍没人来, 需要把这个队伍剔除掉</p>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>, M = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> teamid[M]; <span class="comment">// 存放每个人对应的队伍编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, C = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n, n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Scenario #"</span> &lt;&lt; C++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; cnt;</span><br><span class="line">            <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">                <span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">                teamid[x] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; team; <span class="comment">// 按照顺序存放队伍编号</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; person[n]; <span class="comment">// 存放每个队列里的人</span></span><br><span class="line">        <span class="built_in">string</span> command;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; command, command != <span class="string">"STOP"</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (command == <span class="string">"ENQUEUE"</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">                <span class="keyword">int</span> tid = teamid[x];</span><br><span class="line">                <span class="keyword">if</span> (person[tid].empty()) team.push(tid);</span><br><span class="line">                person[tid].push(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tid = team.front();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; person[tid].front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                person[tid].pop();</span><br><span class="line">                <span class="keyword">if</span> (person[tid].empty()) team.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-131-直方图中最大的矩形"><a href="#Acwing-131-直方图中最大的矩形" class="headerlink" title="Acwing 131. 直方图中最大的矩形"></a><a href="https://www.acwing.com/problem/content/133/" target="_blank" rel="noopener">Acwing 131. 直方图中最大的矩形</a></h2><p>栈小节结束了!</p>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>暴力做法 以某个矩形为中心 向两边搜索 直到比它矮<br>扩展的最大面积就是$(r[i] - l[i] - 1) * heights[i]$<br>$O(N^2)$的复杂度行不通</p>
<p>怎么优化?<br>设当前矩形下标为i<br>如果$i-1$的高度 $&gt; i$的高度 那么$i$后面的矩形的左边界也可以优化计算<br>如果$i+1 &gt; i, i+1$会被 $i$ 限制住, $i+1 &lt; i$ 那 $i+1$ 也一定小于 $i-1$<br>因此计算左边界时 靠左的且较高的可以直接跳过(有点递推的意思</p>
<p>当我们找 i 左边第一个小于 heights[i] 如果 heights[i-1] &gt;= heights[i]<br>其实就是和 heights[i-1] 左边第一个小于 heights[i-1] 一样<br>依次类推，右边同理</p>
<h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> +<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n, n) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="comment">// 不要忘记初始化右边界</span></span><br><span class="line">        vector&lt;int&gt; l(n), r(n, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">size</span>() &amp;&amp; a[st.top()] &gt;= a[i]) &#123;</span><br><span class="line">                <span class="comment">// 如果某个矩形比下一个高 那它的右边界就确定了</span></span><br><span class="line">                r[st.top()] = i;</span><br><span class="line">                <span class="comment">// 跳过高的矩形</span></span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一直弹出左边比当前高的矩形 所以停下来的时候 左边界也可以确定了</span></span><br><span class="line">            l[i] = st.<span class="built_in">size</span>() ? st.top() : <span class="number">-1</span>;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 高度最高1e9 所以答案可能超int</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (<span class="keyword">long</span> <span class="keyword">long</span>)(r[i] - l[i] - <span class="number">1</span>) * a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-130-火车进出栈问题"><a href="#Acwing-130-火车进出栈问题" class="headerlink" title="Acwing 130. 火车进出栈问题"></a><a href="https://www.acwing.com/problem/content/132/" target="_blank" rel="noopener">Acwing 130. 火车进出栈问题</a></h2><p>这道加强数据范围, 不能用dfs了, 做完直接废了<br>分析一下会发现, 进栈出栈这个操作序列, 要出栈必先有进栈<br>把进栈看成左括号, 出栈看成右括号, 这道题就变成合法括号的方案数<br>像合法括号, 合法01序列, 进栈出栈, 这类都是属于组合数中出名的卡特兰数<br>卡特兰数有现成的公式<br>$$<br>\frac{C_{2n}^n}{n + 1} = \frac{2n!}{n!n!(n+1)}<br>$$<br>难点在于, 如何快速计算阶乘且不溢出<br>不溢出可以使用高精度, 快速计算可以选择双指针一边乘一边除<br>只不过这道题数据太强了, 这种做法, 答案的长度变化是先增后减, 这样运行到一半的时候会因为答案过长而超时<br>更理想的做法是, 答案的长度稳定增长, 直到和最终答案长度相同, 不变化<br>本来优化方法使用高精度压位就可以了, 奈何此题就是这么强, 还得继续优化<br>更好的做法是把公式的分母分子分解质因数, 然后上下的质因数个数做差, 剩下的肯定只有分母的质因数, 然后直接计算质因数的积就可以</p>
<h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6000010</span>, M = <span class="number">120010</span>;</span><br><span class="line">ll ans[N], ansL;</span><br><span class="line"><span class="keyword">int</span> prime[M];</span><br><span class="line"><span class="keyword">bool</span> st[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        ret += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ansL; ++i) &#123;</span><br><span class="line">        ans[i] = ans[i] * x + t;</span><br><span class="line">        t = ans[i] / <span class="number">1000000000</span>;</span><br><span class="line">        ans[i] %= <span class="number">1000000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t) &#123;</span><br><span class="line">        ans[++ansL] = t % <span class="number">1000000000</span>;</span><br><span class="line">        t /= <span class="number">1000000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> t = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线性筛素数</span></span><br><span class="line">    getPrime(t);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 减去n!n!部分的质因数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line">            prime[i] = <span class="built_in">get</span>(t, i) - <span class="built_in">get</span>(t - n, i) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减去n+1部分的质因数</span></span><br><span class="line">    <span class="keyword">int</span> k = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k % i == <span class="number">0</span>) &#123;</span><br><span class="line">            --prime[i];</span><br><span class="line">            k /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 高精度乘法</span></span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (prime[i]--) mul(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans[ansL]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ansL - <span class="number">1</span>; ~i; --i) <span class="built_in">printf</span>(<span class="string">"%09lld"</span>, ans[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-129-火车进栈"><a href="#Acwing-129-火车进栈" class="headerlink" title="Acwing 129. 火车进栈"></a><a href="https://www.acwing.com/problem/content/131/" target="_blank" rel="noopener">Acwing 129. 火车进栈</a></h2><p>今天肝两道题,进栈出栈的具体方案和方案数</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>对于$1\sim n$内的每个数, 都可以有进栈出栈两种选择<br>像这种有两种选择, 然后求具体方案的, 就可以用回溯来做<br>时间复杂度$O(2^N)$</p>
<h3 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">int</span> n, remain = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!remain) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">        --remain;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : ans) <span class="built_in">cout</span> &lt;&lt; e;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 答案的回溯</span></span><br><span class="line">    <span class="keyword">if</span> (st.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans.push_back(st.top());</span><br><span class="line">        st.pop();</span><br><span class="line">        dfs(x);</span><br><span class="line">        st.push(ans.back());</span><br><span class="line">        ans.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 栈的回溯</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= n) &#123;</span><br><span class="line">        st.push(x);</span><br><span class="line">        dfs(x + <span class="number">1</span>);</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-128-编辑器"><a href="#Acwing-128-编辑器" class="headerlink" title="Acwing 128. 编辑器"></a><a href="https://www.acwing.com/problem/content/130/" target="_blank" rel="noopener">Acwing 128. 编辑器</a></h2><p>栈的变形, 对顶栈</p>
<h3 id="对顶栈-前缀和-一点点的动态规划"><a href="#对顶栈-前缀和-一点点的动态规划" class="headerlink" title="对顶栈 + 前缀和 + 一点点的动态规划"></a>对顶栈 + 前缀和 + 一点点的动态规划</h3><p>对顶栈我也是今天才接触到, 类似指针/光标在序列中移动的, 就可以考虑对顶栈<br>因为要快速求出当前光标之前的最大值, 先用前缀和处理快速求出区间之和<br>然后再加上一点点的DP, 如果加上当前数没有之前序列大, 那就不加</p>
<h3 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> sl[N], sr[N], topl, topr;</span><br><span class="line"><span class="keyword">int</span> sum[N], maxV[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    sl[++topl] = x;</span><br><span class="line">    sum[topl] = sum[topl - <span class="number">1</span>] + x;</span><br><span class="line">    maxV[topl] = <span class="built_in">max</span>(sum[topl], maxV[topl - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    maxV[<span class="number">0</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">char</span> i;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="string">'I'</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">'D'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (topl) --topl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">'L'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (topl) sr[++topr] = sl[topl--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">'R'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (topr) add(sr[topr--]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; maxV[x] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-41-包含min函数的栈"><a href="#Acwing-41-包含min函数的栈" class="headerlink" title="Acwing 41. 包含min函数的栈"></a><a href="https://www.acwing.com/problem/content/90/" target="_blank" rel="noopener">Acwing 41. 包含min函数的栈</a></h2><p>开始栈的题型</p>
<h3 id="差值计算"><a href="#差值计算" class="headerlink" title="差值计算"></a>差值计算</h3><p>这道题容易想到的做法有, 使用一个辅助栈, 保存实时的最小值</p>
<p>不过这道题还有一个空间复杂度更低的做法, 利用差值计算(时间换空间?)<br>举个例子, 有这么一个操作序列, 压入-1, 3, -4, 取最小值, 弹出, 取栈顶, 取最小值<br>压入-1, 此时栈为空, 因此最小值min = -1, 压入栈-1 - min = 0;<br>压入3, 压入栈3 - min = 4, 更新最小值;<br>压入-4, 压入栈-4 - min = -3, 更新最小值;<br>取最小值, 返回min;<br>弹出, 判断栈顶是否小于0, 如果是, min -= 栈顶, 更新最小值;<br>取栈顶, 返回栈顶与最小值之和(减法的逆运算);<br>取最小值, 返回min.</p>
<h3 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> m;</span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">size</span>()) m = x;</span><br><span class="line">        s.push(x - m);</span><br><span class="line">        m = <span class="built_in">min</span>(m, (<span class="keyword">long</span> <span class="keyword">long</span>)x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t = s.top();</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) m -= t;</span><br><span class="line">        <span class="comment">// m -= (t &gt;&gt; 63) &amp; t; // 骚操作</span></span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.top() &lt; <span class="number">0</span>) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">return</span> m + s.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-127-任务"><a href="#Acwing-127-任务" class="headerlink" title="Acwing 127. 任务"></a><a href="https://www.acwing.com/problem/content/129/" target="_blank" rel="noopener">Acwing 127. 任务</a></h2><p>这道题是贪心部分的题, 如果做过算法竞赛进阶指南中的贪心部分, 就很熟悉</p>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>因为工作时间的比重最大, 所以按照工作时间优先, 工作级别次序的方式排序<br>然后在任务里, 按照工作时间从大到小, 找出符合工作时间的所有机器<br>再找出级别最接近的机器, 这样才不会浪费级别</p>
<p>因为符合工作时间的机器可能有很多台, 所以只能按序枚举<br>而最接近工作级别的只需要一台, 所以可以使用二分<br>在这里使用<code>C++</code>的STL容器<code>multiset</code>, 允许元素重复的<code>set</code>, 支持<code>O(logN)</code>的二分查找</p>
<h3 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line">pii macs[N], tasks[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; macs[i].first &gt;&gt; macs[i].second;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) <span class="built_in">cin</span> &gt;&gt; tasks[i].first &gt;&gt; tasks[i].second;</span><br><span class="line">        <span class="comment">//排序 默认从小到大</span></span><br><span class="line">        sort(macs, macs + n);</span><br><span class="line">        sort(tasks, tasks + m);</span><br><span class="line">        <span class="comment">// 允许重复的set</span></span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用任务去找合适的机器</span></span><br><span class="line">        <span class="comment">// 要从大到小枚举 所以逆序枚举</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>; ~i; --i) &#123;</span><br><span class="line">            <span class="comment">// 满足工作时间的 就拿出来放到set里</span></span><br><span class="line">            <span class="keyword">while</span> (~j &amp;&amp; macs[j].first &gt;= tasks[i].first) </span><br><span class="line">                st.insert(macs[j--].second);</span><br><span class="line">            <span class="comment">// 二分找到最接近级别的机器</span></span><br><span class="line">            <span class="keyword">auto</span> it = st.lower_bound(tasks[i].second);</span><br><span class="line">            <span class="keyword">if</span> (it != st.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                ans += <span class="number">500</span> * tasks[i].first + <span class="number">2</span> * tasks[i].second;</span><br><span class="line">                st.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">' '</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-126-最大的和"><a href="#Acwing-126-最大的和" class="headerlink" title="Acwing 126. 最大的和"></a><a href="https://www.acwing.com/problem/content/128/" target="_blank" rel="noopener">Acwing 126. 最大的和</a></h2><p>是<a href="https://www.acwing.com/problem/content/50/" target="_blank" rel="noopener">最大子数组和</a>的二维版本<br>最大子数组和还有一个进阶版本, 求出具体子数组, 详见<a href="https://www.acwing.com/problem/content/1481/" target="_blank" rel="noopener">1479. 最大子序列和</a></p>
<h3 id="最大子数组和-前缀和"><a href="#最大子数组和-前缀和" class="headerlink" title="最大子数组和 + 前缀和"></a>最大子数组和 + 前缀和</h3><p>一般模板题变成二维后, 大部分做法就是把二维转换成一维, 然后用一维的做法做就行了</p>
<p>这道题把最大子数组和, 变成最大子矩阵和, 如果我们能把子矩阵变成子数组的形式就好了<br>考虑把子矩阵的多行, 想象成只有一行, 这样就变成一维的子数组了!<br>怎么做呢, 把那么多行的值, 按照每列从上到下累加成一个值, 也就是子数组每个元素就是每列的和<br>为了快速求出累加值, 可以使用前缀和处理</p>
<p>剩下的就是想办法枚举出每个子矩阵的值了, 这里直接暴力枚举<br>先枚举出上下边界, 然后每次计算边界内所有子矩阵的值, 使用最大子数组的方式求出最大值<br>由于数据最大100, 所以$N^3$是没有问题的</p>
<p>小结一下, 把矩阵的每一列按照从上到下前缀和处理, 然后确定上下边界, 每次枚举边界内的子矩阵的值</p>
<h3 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="comment">// 列方向前缀和</span></span><br><span class="line">            a[i][j] = a[i - <span class="number">1</span>][j] + x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-128</span>;</span><br><span class="line">    <span class="comment">// 枚举上下边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 在边界内 行方向上扫描计算和</span></span><br><span class="line">            <span class="comment">// 使用最大子数组和的方法计算最大值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = a[j][k] - a[i - <span class="number">1</span>][k];</span><br><span class="line">                f = <span class="built_in">max</span>(f, <span class="number">0</span>) + w;</span><br><span class="line">                ans = <span class="built_in">max</span>(f, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-123-士兵"><a href="#Acwing-123-士兵" class="headerlink" title="Acwing 123. 士兵"></a><a href="https://www.acwing.com/problem/content/125/" target="_blank" rel="noopener">Acwing 123. 士兵</a></h2><p>今天一口气更三道!</p>
<h3 id="排序-中位数"><a href="#排序-中位数" class="headerlink" title="排序 + 中位数"></a>排序 + 中位数</h3><p>这道题是<a href="https://www.acwing.com/problem/content/106/" target="_blank" rel="noopener">货仓选址</a>的二维升级版(话说中位数竟然能衍生这么多题目), 分别从x, y方向来找最小值</p>
<p>这道题存在一个性质, 最终答案的士兵顺序和原始数据排序后的顺序是一样的, 画个图就很清楚<br>因为要想所有士兵走到同一直线最短距离, 每个士兵肯定是选择垂直于最终队列方向的路线, 所以和一开始的顺序一样</p>
<p>x方向上, 我们假设最终队列, 第一个士兵的位置为$a$, 则第$i$个士兵的位置为$a + i - 1$<br>那么x方向上的位移就是$|X_i - (a + i - 1)|$, 可以转换为$|(X_i - i + 1) - a|$<br>形式上就是变量减去一个常数, 要求最小值, 就和货仓选址一样, 是选$(X_i - i + 1)$的数组的中位数作为$a$的值</p>
<p>y方向上, 想象有一条平行于x轴的直线, 如果要想这条线距离所有士兵最近, 也是中位数<br>所以这道题就是中位数拓展到二维版, 然后其中一个方向特殊处理了一下<br>时间复杂度, 排序$O(NlogN)$, 找中位数$O(N)$, 整体$O(NlogN)$</p>
<h3 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line">pii a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpx</span><span class="params">(pii a, pii b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(pii a, pii b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].first &gt;&gt; a[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// y</span></span><br><span class="line">    nth_element(a, a + (n &gt;&gt; <span class="number">1</span>), a + n, cmpy);</span><br><span class="line">    pii mid = a[n &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ans += <span class="built_in">abs</span>(a[i].second - mid.second);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x</span></span><br><span class="line">    sort(a, a + n, cmpx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        a[i].first -= i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nth_element(a, a + (n &gt;&gt; <span class="number">1</span>), a + n, cmpx);</span><br><span class="line">    mid = a[n &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ans += <span class="built_in">abs</span>(a[i].first - mid.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-121-赶牛入圈"><a href="#Acwing-121-赶牛入圈" class="headerlink" title="Acwing 121. 赶牛入圈"></a><a href="https://www.acwing.com/problem/content/123/" target="_blank" rel="noopener">Acwing 121. 赶牛入圈</a></h2><p>一道做完感觉整个人都升华了的题目</p>
<h3 id="二分-双指针-前缀和-离散化"><a href="#二分-双指针-前缀和-离散化" class="headerlink" title="二分 + 双指针 + 前缀和 + 离散化"></a>二分 + 双指针 + 前缀和 + 离散化</h3><p><strong>要求某个最值, 可以考虑二分</strong>, 问题是二分的<code>check()</code>函数怎么写<br>使用二分得到的矩形长度$mid$, 枚举矩形边长, 然后计算矩阵内的草的数量, 与目标值比较<br><strong>区间内草的数量可以使用前缀和优化</strong>, 在$O(1)$内计算出来<br><strong>枚举长度可以使用双指针</strong>, 一前一后保证区间长度在$mid$内<br>问题是坐标范围$1\sim10000$, 如果开个矩阵数组, 每次check的时候遍历数组, <strong>由于是$N^2$, 在时间和空间上都直接起飞</strong><br>注意到最多只有500个点, 也就是说<strong>坐标分布是不均匀的</strong>, 开那么大的数组完全是浪费<br>为此<strong>引入离散化, 优化时空复杂度</strong></p>
<p>什么是离散化? 简单来说, 就是通过映射/哈希的方式, 把大数据的值转成数据的相对顺序的编号<br>通俗来讲, 就是数据太大, 数组不好用, 而且我们只关心元素的相对顺序, 这个时候就可以用离散化<br>离散化的对象可以是整数, 浮点数, 字符串</p>
<p>离散化怎么做? 通常是先去重删除重复元素, 然后排序得到相对顺序, 最后把值修改成排序后的编号</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里因为去重函数要求排序 所以先排序 再去重</span></span><br><span class="line">sort(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">num.erase(unique(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>()), num.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    hash[i] = lower_bound(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), num[i]) - num.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后梳理一下, 二分矩形边长, 计算区间值, 比较, 使用离散化和前缀和进行预处理</p>
<h3 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释一下1000 因为最多500个点 </span></span><br><span class="line"><span class="comment">// 如果每个坐标的x,y两两不同 那最多会有不同的500个x 500个y </span></span><br><span class="line"><span class="comment">// 考虑到离散化之后 新编号可能达到1000 因此前缀和数组大小必须开到1000*1000</span></span><br><span class="line"><span class="comment">// 主要是因为离散化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line">pii points[N]; <span class="comment">// 坐标数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums; <span class="comment">// 用于离散化的数组</span></span><br><span class="line"><span class="keyword">int</span> sum[N][N]; <span class="comment">// 前缀和数组</span></span><br><span class="line"><span class="keyword">int</span> n, C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双指针遍历</span></span><br><span class="line">    <span class="comment">// x1 不在mid区间内的第一个数</span></span><br><span class="line">    <span class="comment">// x2 mid区间的最后一个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">1</span>; x2 &lt; nums.<span class="built_in">size</span>(); ++x2) &#123;</span><br><span class="line">        <span class="comment">// 什么意思? 因为x1和x2是对应的 x2++之后, 需要判断x1还在不在mid范围内</span></span><br><span class="line">        <span class="comment">// 1. x1 + 1 如果x1前一个点 和 x2相减都小于mid 那x1肯定需要前进一步</span></span><br><span class="line">        <span class="comment">// 2. nums[x1 + 1] + 1 是因为这里用坐标代表一个单位矩阵 实际情况需要补上一个单位</span></span><br><span class="line">        <span class="keyword">while</span> (nums[x2] - nums[x1 + <span class="number">1</span>] + <span class="number">1</span> &gt; mid) ++x1;</span><br><span class="line">        <span class="comment">// 同理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y1 = <span class="number">0</span>, y2 = <span class="number">1</span>; y2 &lt; nums.<span class="built_in">size</span>(); ++y2) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[y2] - nums[y1 + <span class="number">1</span>] + <span class="number">1</span> &gt; mid) ++y1;</span><br><span class="line">            <span class="keyword">int</span> t = sum[x2][y2] - sum[x2][y1] - sum[x1][y2] + sum[x1][y1];</span><br><span class="line">            <span class="keyword">if</span> (t &gt;= C) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; C &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入0是因为前缀和要用到下标0 所以也插入离散化一下</span></span><br><span class="line">    nums.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        points[i] = &#123;x, y&#125;;</span><br><span class="line">        nums.push_back(x);</span><br><span class="line">        nums.push_back(y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 离散化三步走 排序去重+按照顺序重新编号</span></span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    nums.erase(unique(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 使用自带的二分查找函数 查找旧数据在新数组的位置</span></span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), points[i].first) - nums.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), points[i].second) - nums.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="comment">// 坐标对应草 草数量+1</span></span><br><span class="line">        ++sum[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前缀和处理</span></span><br><span class="line">    <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; ++j) &#123;</span><br><span class="line">            sum[i][j] += sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始二分</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Acwing寒假每日一题(提高组) 打卡记录 题解</title>
    <url>/archives/465097960/</url>
    <content><![CDATA[<p>(活动已结束)<br>寒假组队学习算法，闫老师带领大家每日刷一道经典算法题。<br>题目难度：中等偏上，题目选自CodeForces、ACM、NOIP、蓝桥杯等比赛真题。</p>
<a id="more"></a>

<p><a href="https://www.acwing.com/user/myspace/index/34956/" target="_blank" rel="noopener">欢迎来Acwing围观我</a><br>点击标题，进入题目。</p>
<h2 id="AcWing-3240-压缩编码"><a href="#AcWing-3240-压缩编码" class="headerlink" title="AcWing 3240. 压缩编码"></a><a href="https://www.acwing.com/problem/content/3243/" target="_blank" rel="noopener">AcWing 3240. 压缩编码</a></h2><p>今天不是图论题了</p>
<h3 id="哈夫曼树变成区间DP"><a href="#哈夫曼树变成区间DP" class="headerlink" title="哈夫曼树变成区间DP"></a>哈夫曼树变成区间DP</h3><p>具体可以看我在Acwing写的题解, 欢迎关注!<br><a href="https://www.acwing.com/solution/content/36694/" target="_blank" rel="noopener">AcWing 3240. 压缩编码 哈夫曼树与区间DP的区别+绘图理解</a></p>
<h2 id="AcWing-3250-通信网络"><a href="#AcWing-3250-通信网络" class="headerlink" title="AcWing 3250. 通信网络"></a><a href="https://www.acwing.com/problem/content/3253/" target="_blank" rel="noopener">AcWing 3250. 通信网络</a></h2><p>又是一道很经典的图论题, dfs标记状态</p>
<h3 id="DFS-标记状态"><a href="#DFS-标记状态" class="headerlink" title="DFS + 标记状态"></a>DFS + 标记状态</h3><p>使用一个<code>st[i][j]</code>数组, 表示 $i$ 到 $j$ 是否连通<br>建立好图之后, dfs跑一遍<br>每次记录当前点和父节点 标记两个点的状态为连通<br>两个点的关系只访问一次<br>最后检查一下状态数组中, 两个点是否连通即可<br>时间复杂度 $O(N^2)$</p>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>, M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], to[M], nxt[M], idx;</span><br><span class="line"><span class="keyword">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    to[idx] = v;</span><br><span class="line">    nxt[idx] = h[u];</span><br><span class="line">    h[u] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每次记录当前点和父节点 标记两个点的状态为连通</span></span><br><span class="line"><span class="comment">两个点的关系只访问一次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> fa, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st[fa][x]) <span class="keyword">return</span> ;</span><br><span class="line">    st[fa][x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; ~i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = to[i];</span><br><span class="line">        dfs(fa, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dfs(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查两两之间是否连通 */</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j] &amp;&amp; !st[j][i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-3215-网络延时"><a href="#AcWing-3215-网络延时" class="headerlink" title="AcWing 3215. 网络延时"></a><a href="https://www.acwing.com/problem/content/3218/" target="_blank" rel="noopener">AcWing 3215. 网络延时</a></h2><p>经典图论板子题</p>
<h3 id="最远点对"><a href="#最远点对" class="headerlink" title="最远点对"></a>最远点对</h3><p>这道题本质上是求图中最远的两个点, 转到树上就变求最远的两个叶子节点, 最远的两个点必然是叶子节点<br>建图用邻接表, 在这里我使用链式前向星建立邻接表<br>然后dfs遍历邻接表, 每次求出当前点的最远和次远叶子节点距离<br>这两个点就是当前点能达到的最远点对, 两者之和就是最远距离<br>遍历的时候取最大值即可</p>
<h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], nxt[N], to[N], idx;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    to[idx] = v;</span><br><span class="line">    nxt[idx] = h[u];</span><br><span class="line">    h[u] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义最远和次远叶节点距离</span></span><br><span class="line">    <span class="keyword">int</span> d1 = <span class="number">0</span>, d2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = to[i];</span><br><span class="line">        <span class="keyword">int</span> t = dfs(j);</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= d1) d2 = d1, d1 = t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; d2) d2 = t;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d1 + d2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d1 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> len = n + m;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为根节点从1开始 所以输入直接从2开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, x; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        add(x, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-3205-最优配餐"><a href="#AcWing-3205-最优配餐" class="headerlink" title="AcWing 3205. 最优配餐"></a><a href="https://www.acwing.com/problem/content/3208/" target="_blank" rel="noopener">AcWing 3205. 最优配餐</a></h2><p>开始做图论咯</p>
<h3 id="多源BFS"><a href="#多源BFS" class="headerlink" title="多源BFS"></a>多源BFS</h3><p>可以以分店/客户坐标作为起点, 然后计算所有点到所有分店/客户的最小距离<br>最后客户到分店/分店到客户的距离 * 订单数即可<br>计算最短距离可以用bfs扩散, 快一点</p>
<h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> customer[M][<span class="number">2</span>], amount[M]; <span class="comment">// 客户坐标 订单数</span></span><br><span class="line"><span class="keyword">bool</span> red[N][N]; <span class="comment">// 不能通过的点</span></span><br><span class="line"><span class="keyword">int</span> dis[N][N]; <span class="comment">//用来记录每个点到分店的最小距离</span></span><br><span class="line"><span class="keyword">int</span> n, m, k, d;</span><br><span class="line"><span class="built_in">queue</span>&lt;pii&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dxy[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.front(); q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, tx, ty; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            tx = t.first + dxy[i][<span class="number">0</span>];</span><br><span class="line">            ty = t.second + dxy[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 注意数据是从1开始</span></span><br><span class="line">            <span class="keyword">if</span> (tx &lt; <span class="number">1</span> || tx &gt; n || ty &lt; <span class="number">1</span> || ty &gt; n || red[tx][ty]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dis[tx][ty] &gt; dis[t.first][t.second] + <span class="number">1</span>) &#123;</span><br><span class="line">                dis[tx][ty] = dis[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q.push(&#123;tx, ty&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入数据 防止TLE</span></span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; d;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="comment">// 把所有分店作为起点去bfs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x, y; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        q.push(&#123;x, y&#125;);</span><br><span class="line">        dis[x][y] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; customer[i][<span class="number">0</span>] &gt;&gt; customer[i][<span class="number">1</span>] &gt;&gt; amount[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x, y; i &lt; d; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        red[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// bfs得到所有点的距离</span></span><br><span class="line">    bfs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出最小距离 * 订单数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        ans += dis[customer[i][<span class="number">0</span>]][customer[i][<span class="number">1</span>]] * amount[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-3195-有趣的数"><a href="#AcWing-3195-有趣的数" class="headerlink" title="AcWing 3195. 有趣的数"></a><a href="https://www.acwing.com/problem/content/3198/" target="_blank" rel="noopener">AcWing 3195. 有趣的数</a></h2><p>难得的动态规划</p>
<h3 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h3><p>按照规则<br>最高位不能为0, 因此第一位不会为0<br>0必须在1前面 所以第一位也不会为1<br>2必须在3前面 所以第一位不会为3<br>因此初始状态只能是2<br>确定初始状态后, 就能确定后续状态如下<br>0: 用了2, 还剩0, 1, 3, 初始状态<br>1: 用了2, 0, 还剩1, 3<br>2: 用了2, 3, 还剩0, 1<br>3: 用了2, 0, 1, 还剩3<br>4: 用了2, 0, 3, 还剩1<br>5: 用了2, 0, 3, 1<br>一共六种状态<br>其中状态转移为<br>0-&gt;0 0-&gt;1 0-&gt;2<br>1-&gt;1 1-&gt;3 1-&gt;4<br>2-&gt;2 2-&gt;4 2-&gt;5<br>3-&gt;3 3-&gt;5<br>4-&gt;4 4-&gt;5<br>5-&gt;5</p>
<p>绘制成图如下<br><img src="https://s3.ax1x.com/2021/02/16/ycAWlQ.png" alt=""><br>比如, 指向状态 $0123$ 圈圈的箭头表示，$0123$ 状态只能由本身及 $012$ 和 $023$ 状态转移过来<br>时间复杂度 $O(N)$</p>
<h3 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">1005</span>][<span class="number">6</span>];</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll a2, a02, a23, a012, a023, a0123;</span><br><span class="line">ll t2, t02, t23, t012, t023, t0123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 一开始每种状态的答案都为0 还没使用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 乘以2 表示可以填两种</span></span><br><span class="line">        ll j = i - <span class="number">1</span>;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[i][<span class="number">1</span>] = (f[j][<span class="number">0</span>] + f[j][<span class="number">1</span>] * <span class="number">2</span>) % mod;</span><br><span class="line">        f[i][<span class="number">2</span>] = (f[j][<span class="number">0</span>] + f[j][<span class="number">2</span>]) % mod;</span><br><span class="line">        f[i][<span class="number">3</span>] = (f[j][<span class="number">1</span>] + f[j][<span class="number">3</span>] * <span class="number">2</span>) % mod;</span><br><span class="line">        f[i][<span class="number">4</span>] = (f[j][<span class="number">1</span>] + f[j][<span class="number">2</span>] + f[j][<span class="number">4</span>] * <span class="number">2</span>) % mod;</span><br><span class="line">        f[i][<span class="number">5</span>] = (f[j][<span class="number">3</span>] + f[j][<span class="number">4</span>] + f[j][<span class="number">5</span>] * <span class="number">2</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 优化做法 */</span></span><br><span class="line">    <span class="comment">// 由于每次只用到 i - 1 因此可以优化成滚动更新</span></span><br><span class="line">    a2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 使用上一次 也就是 i - 1的数据</span></span><br><span class="line">        t2 = a2, t02 = a02, t23 = a23, t012 = a012, t023 = a023, t0123 = a0123;</span><br><span class="line">        a2 = t2 % mod;</span><br><span class="line">        a02 = (t2 + t02 * <span class="number">2</span>) % mod;</span><br><span class="line">        a23 = (t2 + t23) % mod;</span><br><span class="line">        a012 = (t02 + t012 * <span class="number">2</span>) % mod;</span><br><span class="line">        a023 = (t02 + t23 + t023 * <span class="number">2</span>) % mod;</span><br><span class="line">        a0123 = (t012 + t023 + t0123 * <span class="number">2</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a0123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="AcWing-730-机器人跳跃问题"><a href="#AcWing-730-机器人跳跃问题" class="headerlink" title="AcWing 730. 机器人跳跃问题"></a><a href="https://www.acwing.com/problem/content/732/" target="_blank" rel="noopener">AcWing 730. 机器人跳跃问题</a></h2><p>一看到最小就想到二分, 其实这道题和上道题搭积木一样, 也可以反向思考</p>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>二分值, 然后每次按照规则走一遍即可<br>不过这道题有个小细节, 如果你走到了序列的最大值, 按照规则, 你接下去只增不减, 肯定能到达终点, 这个时候直接返回即可<br>时间复杂度 $O(NlogN)$</p>
<h3 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="keyword">int</span> n, maxv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        e += e - h[i];</span><br><span class="line">        <span class="keyword">if</span> (e &gt;= maxv) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 做法一 二分 */</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; h[i], maxv = <span class="built_in">max</span>(maxv, h[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e5</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="贪心-反向思考"><a href="#贪心-反向思考" class="headerlink" title="贪心(反向思考)"></a>贪心(反向思考)</h3><p>按照最优策略考虑, 如果走到终点, 能量刚好用完, 那一定是要求的最小值<br>所以逆序遍历, 按照规则反过来求最初值<br>注意题目要求向上取整, 对规则进行逆运算的时候, 用到了除法, 所以要对奇数偶数分别处理<br>时间复杂度 $O(N)$</p>
<h3 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="comment">/* 做法二 贪心 */</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; h[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> init = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, t; ~i; --i) &#123;</span><br><span class="line">        t = init + h[i];</span><br><span class="line">        <span class="comment">// 用位运算代替除法 奇数就加1 偶数不需要</span></span><br><span class="line">        init = (t &gt;&gt; <span class="number">1</span>) + (t &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; init;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-507-积木大赛"><a href="#AcWing-507-积木大赛" class="headerlink" title="AcWing 507. 积木大赛"></a><a href="https://www.acwing.com/problem/content/509/" target="_blank" rel="noopener">AcWing 507. 积木大赛</a></h2><p>差分的拓展题, 逆向思考</p>
<h3 id="差分-贪心"><a href="#差分-贪心" class="headerlink" title="差分 + 贪心"></a>差分 + 贪心</h3><p>区间操作, 很容易联想到差分处理<br>题目要求从0变到目标序列, 我们可以反向思考, 从目标序列变成0<br>也就是在区间上$[L, R]$减一, 转移到差分数组, 就是 $b[L] -= 1, b[R + 1] += 1$<br>又因为全0序列的差分序列也是全0, 也就是问你多少次区间操作能把差分序列变为0<br>既然要减一变为0, 对于差分数组中每个 $b_i &gt; 0$, 至少需要减去 $b_i$次<br>所以<strong>总次数至少是差分序列中所有正数之和</strong><br>那有没有办法可以做到操作次数一定是所有正数之和?<br>可以这样操作: 从后往前操作，如果当前的 $b_i&gt;0$，则将其减1，并将其后的某个负数加1<br>证明如下:<br>由于差分数组的所有后缀 $\displaystyle\sum_{i=k}^{n}b_i = -h_k &lt;= 0$<br>因此在所有后缀组合中, 正数的个数肯定小于负数, 所以总能找到对应的负数消除掉所有正数</p>
<h3 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) ans += <span class="built_in">max</span>(<span class="number">0</span>, a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-148-合并果子"><a href="#AcWing-148-合并果子" class="headerlink" title="AcWing 148. 合并果子"></a><a href="https://www.acwing.com/problem/content/150/" target="_blank" rel="noopener">AcWing 148. 合并果子</a></h2><p>拓展题: <a href="https://www.acwing.com/problem/content/284/" target="_blank" rel="noopener">AcWing 282. 石子合并</a><br>两道题看起来很相似, 但是石子合并多了一个限制, 就变成了不一样的题</p>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>理解题意, 就可以发现其实是哈夫曼树的模板题<br>哈夫曼树, 就是每次去所有数据里最小的两个, 合并成一个, 最后只剩下一个数据</p>
<h3 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        q.push(t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        t = q.top(); q.pop();</span><br><span class="line">        t += q.top(); q.pop();</span><br><span class="line">        ans += t;</span><br><span class="line">        q.push(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="AcWing-496-机器翻译"><a href="#AcWing-496-机器翻译" class="headerlink" title="AcWing 496. 机器翻译"></a><a href="https://www.acwing.com/problem/content/498/" target="_blank" rel="noopener">AcWing 496. 机器翻译</a></h2><p>一道模拟题 让我想起了万恶的面试算法LRU</p>
<h3 id="队列-哈希"><a href="#队列-哈希" class="headerlink" title="队列 + 哈希"></a>队列 + 哈希</h3><p>是否在内存, 用一个哈希标记即可<br>要清空最早的元素, 用队列<br>时间复杂度 $O(N)$<br>如果是Java, 直接反手一个LinkedHashMap(然后面试官就让你等通知</p>
<h3 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> cache[<span class="number">1005</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> capacity, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果内存已存在 则直接返回</span></span><br><span class="line"><span class="comment">如果不存在 需要插入</span></span><br><span class="line"><span class="comment">插入后需要检查大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[x]) <span class="keyword">return</span> ;</span><br><span class="line">    q.push(x);</span><br><span class="line">    cache[x] = <span class="number">1</span>;</span><br><span class="line">    ++ans;</span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; capacity) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.front(); q.pop();</span><br><span class="line">        cache[t] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; capacity &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="built_in">put</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-211-计算系数"><a href="#AcWing-211-计算系数" class="headerlink" title="AcWing 211. 计算系数"></a><a href="https://www.acwing.com/problem/content/213/" target="_blank" rel="noopener">AcWing 211. 计算系数</a></h2><p>是我不熟悉的数学题(doge</p>
<h3 id="二项式定理-逆元"><a href="#二项式定理-逆元" class="headerlink" title="二项式定理 + 逆元"></a>二项式定理 + 逆元</h3><p>和这道题有关的有一个二项式定理<br>$(a+b)^k = \displaystyle\sum_{i=0}^{k}{C_k^i a^i b^{k-i}}$<br>通过这个定理, 我们可以求出题目要求的 $x^n, y^m$的系数就是 $C_k^n a^n b^m$<br>现在只需要想出怎么计算即可</p>
<ul>
<li>$a^n \enspace b^m$ 由于题目给了模数 很容易想到 用快速幂解决</li>
<li>$C_k^n = \frac{k * (k-1) * … * (k - n + 1)} {1 * 2 * … * n}$ 涉及到除法取模 而乘法逆元就是为此而生的</li>
<li>乘法逆元 由于模数$10007$是质数 因此可以借助费马小定理 即 $b$ 的逆元 $inv(b) = b^{mod - 2}$<h3 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">10007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    a %= mod;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, k, n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; k &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//C(k, n) * a^n * b^m</span></span><br><span class="line">    <span class="comment">//a^n  b^m 使用快速幂</span></span><br><span class="line">    <span class="keyword">int</span> ans = ksm(a, n) * ksm(b, m) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C(k, n) = (k * k-1 * ... * 1) / (1 * 2 * ... * n);</span></span><br><span class="line">    <span class="comment">// 一边乘一边除 因为mod=10007是质数 除法可以用乘法逆元</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = k; i &lt;= n; ++i, --j) &#123;</span><br><span class="line">        ans = ans * j % mod;</span><br><span class="line">        ans = ans * ksm(i, <span class="number">10005</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="AcWing-312-乌龟棋"><a href="#AcWing-312-乌龟棋" class="headerlink" title="AcWing 312. 乌龟棋"></a><a href="https://www.acwing.com/problem/content/314/" target="_blank" rel="noopener">AcWing 312. 乌龟棋</a></h2><p>说实话只能想到暴力, 因为数据也不大, 顶多 $40^4$<br>然后没想到这叫线性DP(?迷惑)</p>
<h3 id="暴力-线性DP"><a href="#暴力-线性DP" class="headerlink" title="暴力/线性DP"></a>暴力/线性DP</h3><p>直接对4种卡片的所有可能性进行枚举<br>可以利用动态规划的状态表示<br>用 $f[Card_A][Card_B][Card_C][Card_D]$ 来表示第 $i$ 种卡片使用了 $Card_i$ 张的最大分数<br>以使用一张 $A$ 卡为例, 分数的计算公式是 $f[Card_A - 1][Card_B][Card_C][Card_D] + score[A + 2 * B + 3 * C + 4 * D]$<br>时间复杂度 $O(40^4)$</p>
<h3 id="参考代码-10"><a href="#参考代码-10" class="headerlink" title="参考代码"></a>参考代码</h3><p>注意数组不要开太大, 4次方一下子就超出空间限制了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">355</span>, M = <span class="number">45</span>;</span><br><span class="line"><span class="keyword">int</span> f[M][M][M][M];</span><br><span class="line"><span class="keyword">int</span> score[N], b[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n , m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; score[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        ++b[t];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> A = <span class="number">0</span>; A &lt;= b[<span class="number">1</span>]; A ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> B = <span class="number">0</span>; B &lt;= b[<span class="number">2</span>]; B ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> C = <span class="number">0</span>; C &lt;= b[<span class="number">3</span>]; C ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> D = <span class="number">0</span>; D &lt;= b[<span class="number">4</span>]; D ++ ) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = score[A + B * <span class="number">2</span> + C * <span class="number">3</span> + D * <span class="number">4</span>];</span><br><span class="line">                    <span class="keyword">int</span> &amp;v = f[A][B][C][D];</span><br><span class="line">                    v = t;</span><br><span class="line">                    <span class="keyword">if</span> (A) v = <span class="built_in">max</span>(v, f[A - <span class="number">1</span>][B][C][D] + t);</span><br><span class="line">                    <span class="keyword">if</span> (B) v = <span class="built_in">max</span>(v, f[A][B - <span class="number">1</span>][C][D] + t);</span><br><span class="line">                    <span class="keyword">if</span> (C) v = <span class="built_in">max</span>(v, f[A][B][C - <span class="number">1</span>][D] + t);</span><br><span class="line">                    <span class="keyword">if</span> (D) v = <span class="built_in">max</span>(v, f[A][B][C][D - <span class="number">1</span>] + t);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[b[<span class="number">1</span>]][b[<span class="number">2</span>]][b[<span class="number">3</span>]][b[<span class="number">4</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-1262-鱼塘钓鱼"><a href="#AcWing-1262-鱼塘钓鱼" class="headerlink" title="AcWing 1262. 鱼塘钓鱼"></a><a href="https://www.acwing.com/problem/content/1264/" target="_blank" rel="noopener">AcWing 1262. 鱼塘钓鱼</a></h2><p>感觉是有动态规划解法的, 但是只能想到暴力枚举的做法, 顶多加个堆优化一下<br>待更新更好的解法</p>
<h3 id="暴力枚举-堆"><a href="#暴力枚举-堆" class="headerlink" title="暴力枚举 + 堆"></a>暴力枚举 + 堆</h3><p>枚举只在前 $i$ 个鱼塘钓鱼, 然后求得到的钓鱼量, 然后取最大值<br>求得到的钓鱼量, 用总的钓鱼时间减去移动时间得到在钓鱼的时间, 然后枚举在钓鱼的每一分钟<br>最优策略是, 每分钟只去能得到最多鱼的池塘钓鱼, 最后把得到的答案更新<br>移动时间可以用前缀和处理, 快速得到前 $i$ 个鱼塘的移动时间<br>求每分钟最多鱼的鱼塘, 可以用堆</p>
<h3 id="参考代码-11"><a href="#参考代码-11" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一分钟鱼数量 每分钟减少量 去下一个鱼塘的时间</span></span><br><span class="line"><span class="keyword">int</span> a[N], d[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">    <span class="comment">//因为要快速求出 i 个鱼塘的移动时间 所以用前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; s[i], s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//暴力枚举 只在前i个鱼塘钓鱼得到的鱼数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; s[i] &lt;= T; ++i) &#123;</span><br><span class="line">        <span class="comment">//因为每次要遍历这i个鱼塘 取得最大值</span></span><br><span class="line">        <span class="comment">//所以用堆来优化一下</span></span><br><span class="line">        priority_queue&lt;pii&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) q.push(&#123;a[j], d[j]&#125;);</span><br><span class="line">        <span class="comment">//前i个鱼塘的鱼数量 以及除去移动时间的钓鱼总时间</span></span><br><span class="line">        <span class="keyword">int</span> tans = <span class="number">0</span>, t = T - s[i];</span><br><span class="line">        <span class="comment">//枚举在钓鱼的每一分钟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; ++j) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.top(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (p.first &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            tans += p.first; <span class="comment">//每分钟的钓鱼量</span></span><br><span class="line">            p.first -= p.second; <span class="comment">//每分钟减少钓鱼量</span></span><br><span class="line">            q.push(p);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, tans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-257-关押罪犯"><a href="#AcWing-257-关押罪犯" class="headerlink" title="AcWing 257. 关押罪犯"></a><a href="https://www.acwing.com/problem/content/259/" target="_blank" rel="noopener">AcWing 257. 关押罪犯</a></h2><p>把罪犯看作点, 怒气值看作边权, 就是图论题.</p>
<p>这题有两个做法, 是做完能得到很大收获的一道题.<br>染色二分图的判断模板: <a href="https://www.acwing.com/problem/content/862" target="_blank" rel="noopener">AcWing 860. 染色法判定二分图</a><br>并查集模板: <a href="https://www.acwing.com/problem/content/240/" target="_blank" rel="noopener">Acwing 238. 银河英雄传说</a></p>
<h3 id="排序-并查集"><a href="#排序-并查集" class="headerlink" title="排序 + 并查集"></a>排序 + 并查集</h3><p>既然题目要求最小的怒气值, 那么干脆按照怒气值排序, 然后依次把两个罪犯分到两个监狱<br>如果做不到, 由于边权的有序性(?)，显然当前的怨气值就是答案中要求的最小怨气值<br>可以把放到同一个监狱这个操作, 看成并查集的合并<br>问题在于, 由于两个监狱两个罪犯, 会有两种合并可能</p>
<ol>
<li>$a$ 罪犯分到 $X$ 监狱, $b$ 罪犯分到 $Y$ 监狱</li>
<li>$a$ 罪犯分到 $Y$ 监狱, $b$ 罪犯分到 $X$ 监狱</li>
</ol>
<p>解决方法为, 先不急着合并, 只保存两者的相对关系, 表示两者不在同一个监狱<br>等到下次出现新的关系比如 $a$ 和 $c$, 因为最优策略是放到不同监狱, 也就是说 $c$ 会被放到和 $b$ 同一个监狱<br>这个时候把 $b$ 和 $c$ 合并即可<br>时间复杂度$O(NlogN)$, 此处 $N$ 为边数</p>
<h3 id="参考代码-12"><a href="#参考代码-12" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">5</span>, M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> p[N]; <span class="comment">// 并查集的父节点</span></span><br><span class="line"><span class="keyword">int</span> opp[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写排序规则</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt; o.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">find</span>(a), y = <span class="built_in">find</span>(b);</span><br><span class="line">    p[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; e[i].a &gt;&gt; e[i].b &gt;&gt; e[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(e, e + m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化父节点数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line">        <span class="comment">//如果两个的父节点相同 即监狱相同 说明此时冲突</span></span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e[i].c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果两者不存在相对关系</span></span><br><span class="line">        <span class="keyword">if</span> (!opp[a]) opp[a] = b;</span><br><span class="line">        <span class="comment">//如果有相对关系 则与相对的点合并</span></span><br><span class="line">        <span class="keyword">else</span> merge(opp[a], b);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//同理</span></span><br><span class="line">        <span class="keyword">if</span> (!opp[b]) opp[b] = a;</span><br><span class="line">        <span class="keyword">else</span> merge(opp[b], a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有则输出0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分-染色二分图判断"><a href="#二分-染色二分图判断" class="headerlink" title="二分 + 染色二分图判断"></a>二分 + 染色二分图判断</h3><p>分成两个监狱, 可以想到用二分图<br>要求最大值最小, 可以用二分怒气值, 如果当前怒气值可行, 那说明更小的也行, 缩小右区间<br>二分怒气值, 然后安排监狱也就是染色二分图, 如果二分图可以染色成功, 就是监狱分配成功, 反之失败.<br>时间复杂度$O((N+M)logC)$, 此处 $N$ 为点数, $M$ 为边数, $C$ 为最大怒气值</p>
<h3 id="参考代码-13"><a href="#参考代码-13" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e4</span> + <span class="number">5</span>, M = <span class="number">2e5</span> + <span class="number">5</span>; <span class="comment">//需要开两倍... 不然会死循环</span></span><br><span class="line"><span class="keyword">int</span> h[N], to[M], nxt[M], w[M], cnt; <span class="comment">//链式前向星 建立邻接表</span></span><br><span class="line"><span class="keyword">int</span> color[N]; <span class="comment">//二分图染色数组</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    w[cnt] = c;</span><br><span class="line">    to[cnt] = b;</span><br><span class="line">    nxt[cnt] = h[a];</span><br><span class="line">    h[a] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="comment">//如果边小于等于mid 那么这俩点可以在一个监狱里</span></span><br><span class="line">        <span class="comment">//只有大于mid时才不能在监狱里 所以可以把小于等于mid的点跳过</span></span><br><span class="line">        <span class="comment">//相当于小剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (w[i] &lt;= mid) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> j = to[i];</span><br><span class="line">        <span class="comment">//如果已经染过色 就不用染了</span></span><br><span class="line">        <span class="keyword">if</span> (color[j]) &#123;</span><br><span class="line">            <span class="comment">//如果颜色和上一个相同</span></span><br><span class="line">            <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//染下一个点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!dfs(j, <span class="number">3</span> - c, mid)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(i, <span class="number">1</span>, mid)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        add(a, b, c);</span><br><span class="line">        add(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-503-借教室"><a href="#AcWing-503-借教室" class="headerlink" title="AcWing 503. 借教室"></a><a href="https://www.acwing.com/problem/content/505/" target="_blank" rel="noopener">AcWing 503. 借教室</a></h2><p>和 <a href="https://www.acwing.com/problem/content/501/" target="_blank" rel="noopener">AcWing 499. 聪明的质监员</a> 类似的一道题</p>
<h3 id="二分-差分"><a href="#二分-差分" class="headerlink" title="二分 + 差分"></a>二分 + 差分</h3><p>随着天数推进，被借走的教室越来越多，剩余的教室越来越少，也就是单调递减<br>因此可以使用二分来找到教室不够用的那一天</p>
<p>接着要处理的就是快速求出每天教室的数量<br>由于是在天数的区间上借教室，也就是对区间进行常数运算<br>考虑使用差分进行借教室的操作，然后求和得出教室数量<br>差分模板：<a href="https://www.acwing.com/problem/content/799/" target="_blank" rel="noopener">AcWing 797. 差分</a><br>$PS$: 前缀和的差分是原数列，差分的前缀和是原数列</p>
<p>时间复杂度 $O(klog(n))$</p>
<h3 id="参考代码-14"><a href="#参考代码-14" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> r[N], d[N], st[N], ed[N];</span><br><span class="line">ll dif[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拷贝差分数组到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dif[i] = r[i];</span><br><span class="line">    <span class="comment">//差分数组的区间操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mid; ++i) &#123;</span><br><span class="line">        dif[st[i]] -= d[i];</span><br><span class="line">        dif[ed[i] + <span class="number">1</span>] += d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求和还原到原数列</span></span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ret += dif[i];</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; r[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; d[i] &gt;&gt; st[i] &gt;&gt; ed[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理成差分数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) r[i] -= r[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = m;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (check(l)) <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; l;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="AcWing-499-聪明的质监员"><a href="#AcWing-499-聪明的质监员" class="headerlink" title="AcWing 499. 聪明的质监员"></a><a href="https://www.acwing.com/problem/content/501/" target="_blank" rel="noopener">AcWing 499. 聪明的质监员</a></h2><h3 id="二分-前缀和"><a href="#二分-前缀和" class="headerlink" title="二分 + 前缀和"></a>二分 + 前缀和</h3><p>区间上的检验值 $Y_i$ = 区间矿石个数 * 价值之和，前提是$W_i$ &gt;= $W$<br>也就是说 $W$ 越大 符合要求的矿石越少 自然 $Y_i$ 越小 则 $Y$ 越小<br>所以 $Y$ 和 $W$ 成反比，也就是单调递减<br>考虑使用二分找出最佳的 $W$</p>
<p>然后就是 $Y_i$ 的计算<br>为了快速求出区间上符合要求的个数以及对应的价值之和<br>用前缀和预处理 就可以快速得到结果</p>
<p>还有一个问题，当最后一次二分, 区间的长度最后为$2$时<br>有可能 $getY(l) &gt; S$, $getY(r) &lt; S$, 也有可能反过来，在这里取前者<br>此时需要对两个答案进行比较，才能确定哪个是最优解</p>
<p>我使用的二分是 $l = mid + 1, r = mid$<br>当区间长度为2时, $r = l + 1, mid = (l + r) / 2 = l$<br>最后肯定是 $getY(mid) = getY(l) &gt; S$, 然后 $l = mid + 1 = r$, 结束二分<br>所以需要对结束二分前的 $mid$, 和结束后的 $mid + 1$ 进行比较<br>此时 $mid + 1 = l = r, mid = l - 1 = r - 1$<br>所以是对 $getY(l - 1)$ 和 $getY(l)$ 或者 $getY(r - 1)$ 和 $getY(r)$ 进行比较得到答案</p>
<p>$PS$: 如果你采用的是 $l = mid, r = mid - 1$, 可以自己进行推导, 此时需要比较的是 $getY(l)$ 和 $getY(l + 1)$</p>
<h3 id="参考代码-15"><a href="#参考代码-15" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> w[N], v[N], L[N], R[N], cnt[N];</span><br><span class="line">ll S, sum[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getY</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w[i] &gt;= mid) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + v[i];</span><br><span class="line">            cnt[i] = cnt[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>];</span><br><span class="line">            cnt[i] = cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        ret += (cnt[R[i]] - cnt[L[i] - <span class="number">1</span>]) * (sum[R[i]] - sum[L[i] - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) <span class="built_in">cin</span> &gt;&gt; L[i] &gt;&gt; R[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (getY(mid) &gt; S) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>(<span class="built_in">abs</span>(getY(l) - S), <span class="built_in">abs</span>(getY(l - <span class="number">1</span>) - S));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AcWing-125-耍杂技的牛"><a href="#AcWing-125-耍杂技的牛" class="headerlink" title="AcWing 125. 耍杂技的牛"></a><a href="https://www.acwing.com/problem/content/127/" target="_blank" rel="noopener">AcWing 125. 耍杂技的牛</a></h2><p>与 <a href="https://www.acwing.com/problem/content/116/" target="_blank" rel="noopener">AcWing 114. 国王游戏</a> 相同套路的一道题</p>
<h3 id="排序-贪心"><a href="#排序-贪心" class="headerlink" title="排序 + 贪心"></a>排序 + 贪心</h3><p>时间复杂度 $O(nlog(n))$<br>做法：按照牛的重量与强壮程度之和 $W_i + S_i$ 排序，得到的便是最优做法。</p>
<p>证明：<br>第 $i$ 头牛的危险程度： $\displaystyle\sum_{j=1}^{i - 1}{W_j} - S_i$</p>
<p>接下来列出两头牛在位置顺序交换前后的危险程度</p>
<table>
<thead>
<tr>
<th>牛</th>
<th>交换前</th>
<th>交换后</th>
</tr>
</thead>
<tbody><tr>
<td>$i$</td>
<td>$\displaystyle\sum_{j=1}^{i - 1}{W_j} - S_i$</td>
<td>$\displaystyle\sum_{j=1}^{i - 1}{W_j} + W_{i+1} - S_i$</td>
</tr>
<tr>
<td>$i + 1$</td>
<td>$\displaystyle\sum_{j=1}^{i}{W_j} - S_{i+1}$</td>
<td>$\displaystyle\sum_{j=1}^{i-1}{W_j} - S_{i+1}$</td>
</tr>
</tbody></table>
<p>化简式子，减去$\displaystyle\sum_{j=1}^{i-1}{W_j}$</p>
<table>
<thead>
<tr>
<th>牛</th>
<th>交换前</th>
<th>交换后</th>
</tr>
</thead>
<tbody><tr>
<td>$i$</td>
<td>$- S_i (a)$</td>
<td>$W_{i+1} - S_i (b)$</td>
</tr>
<tr>
<td>$i + 1$</td>
<td>$W_i - S_{i+1} (c)$</td>
<td>$- S_{i+1} (d)$</td>
</tr>
</tbody></table>
<p>首先，明显 $a &lt; b, d &lt; c$<br>所以如果能得出 $b$ 和 $c$ 的关系，就能比较交换前后危险程度的大小<br>当 $W_{i+1} - S_i$ &gt;= $W_i - S_{i+1}$，移项变成$W_{i+1} + S_{i+1}$ &gt;= $W_i + S_i$，交换前的危险程度更小<br>当 $W_{i+1} - S_i$ &lt; $W_i - S_{i+1}$，移项变成$W_{i+1} + S_{i+1}$ &lt; $W_i + S_i$，交换前后的危险程度更小</p>
<p>可知交换前后的危险程度和 $W_i + S_i$ 有关，到此证毕。</p>
<p>具体做法：根据 $W_i + S_i$ 排序，然后枚举记录更大的危险程度，输出即可。</p>
<h3 id="参考代码-16"><a href="#参考代码-16" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line">pii a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> w, s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="comment">//因为sort函数是按照数组第一维来排序的</span></span><br><span class="line">        <span class="comment">//为了方便排序 直接把数组第一维变成两者之和</span></span><br><span class="line">        a[i] = &#123;w + s, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-0x3f3f3f3f</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = a[i].second, s = a[i].first - w;</span><br><span class="line">        <span class="comment">//记录更大的危险程度 重量减去强壮程度</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, sum - s);</span><br><span class="line">        <span class="comment">//计算重量之和</span></span><br><span class="line">        sum += w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Acwing寒假每日一题(入门组) 打卡记录 题解</title>
    <url>/archives/2940978202/</url>
    <content><![CDATA[<p>(活动已结束)<br>寒假组队学习算法，闫老师带领大家每日刷一道经典算法题。<br>题目难度：入门级别。</p>
<a id="more"></a>

<p><a href="https://www.acwing.com/user/myspace/index/34956/" target="_blank" rel="noopener">欢迎来Acwing围观我</a><br>点击标题，进入题目。</p>
<h2 id="Acwing-3257-跳一跳"><a href="#Acwing-3257-跳一跳" class="headerlink" title="Acwing 3257. 跳一跳"></a><a href="https://www.acwing.com/problem/content/3260/" target="_blank" rel="noopener">Acwing 3257. 跳一跳</a></h2><p>每日一题要结束了! 庆祝自己按时全部打卡成功!</p>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) ++ans, last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> last += <span class="number">2</span>, ans += last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-3227-折点计数"><a href="#Acwing-3227-折点计数" class="headerlink" title="Acwing 3227. 折点计数"></a><a href="https://www.acwing.com/problem/content/3230/" target="_blank" rel="noopener">Acwing 3227. 折点计数</a></h2><p>和昨天一样的水题</p>
<h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> ans, a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    --n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] &lt; a[i] &amp;&amp; a[i] &gt; a[i + <span class="number">1</span>] || a[i - <span class="number">1</span>] &gt; a[i] &amp;&amp; a[i] &lt; a[i + <span class="number">1</span>])</span><br><span class="line">            ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-3232-最大波动"><a href="#Acwing-3232-最大波动" class="headerlink" title="Acwing 3232. 最大波动"></a><a href="https://www.acwing.com/problem/content/3235/" target="_blank" rel="noopener">Acwing 3232. 最大波动</a></h2><p>好水的题 直接枚举前后两天之差即可</p>
<h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">abs</span>(a[i] - a[i - <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-3203-画图"><a href="#Acwing-3203-画图" class="headerlink" title="Acwing 3203. 画图"></a><a href="https://www.acwing.com/problem/content/3206/" target="_blank" rel="noopener">Acwing 3203. 画图</a></h2><h3 id="计数统计"><a href="#计数统计" class="headerlink" title="计数统计"></a>计数统计</h3><p>对于这种<strong>只需要计数, 不需要考虑重复数据</strong>的题目<br>能想到的好办法就是计数<br>从起始坐标遍历到结束坐标, 每个方格用某个角的坐标来描述, 记录坐标即可<br>我在这里选择左下角<br>时间复杂度 $O(XYN)$<br>每组数据都要遍历 $|X| * |Y|$ 次, $|X| \enspace |Y|$ 为横/纵坐标之差, 一共有 $N$ 组 </p>
<h3 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="comment">/* 输入 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        <span class="comment">/* 开始遍历 记录左下角 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = x1; x &lt; x2; ++x)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = y1; y &lt; y2; ++y) </span><br><span class="line">                <span class="comment">/* 标记 */</span></span><br><span class="line">                st[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 统计 */</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">            ans += st[i][j];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-3208-Z字形扫描"><a href="#Acwing-3208-Z字形扫描" class="headerlink" title="Acwing 3208. Z字形扫描"></a><a href="https://www.acwing.com/problem/content/3211/" target="_blank" rel="noopener">Acwing 3208. Z字形扫描</a></h2><p>找规律, 模拟</p>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>一个矩阵一共有 $2n-1$ 条对角线<br>把对角线分成两类 右上和左下<br>对于每一条对角线 都有 $x + y = C1 \enspace x - y = C2$<br>也就是说 对角线的坐标之差/坐标之和是固定的<br>因此可以利用这个关系来算坐标<br>最后判断一下边界即可<br>因为减法肯定不会超出矩阵范围 所以使用减法比较方便<br>时间复杂度 $O(N^2)$</p>
<h3 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) </span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对角线个数</span></span><br><span class="line">    <span class="keyword">int</span> len = n &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    <span class="comment">// 循环2n - 1 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="comment">// 从第0条开始 第0条是右上</span></span><br><span class="line">        <span class="comment">// 因此偶数右上 奇数左下</span></span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 奇数左下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="comment">// 判断边界</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; i - j &gt;= <span class="number">0</span> &amp;&amp; i - j &lt; n)</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; a[j][i - j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 偶数右上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; ~j; --j) &#123;</span><br><span class="line">                <span class="comment">// 判断边界</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; i - j &gt;= <span class="number">0</span> &amp;&amp; i - j &lt; n)</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; a[j][i - j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Acwing-1477-拼写正确"><a href="#Acwing-1477-拼写正确" class="headerlink" title="Acwing 1477. 拼写正确"></a><a href="https://www.acwing.com/problem/content/1479/" target="_blank" rel="noopener">Acwing 1477. 拼写正确</a></h2><p>连续几日都是模拟, 数字, 字符串处理</p>
<h3 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">string</span> num[<span class="number">12</span>] = &#123;<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"five"</span>, <span class="string">"six"</span>, <span class="string">"seven"</span>, <span class="string">"eight"</span>, <span class="string">"nine"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) sum += s[i] - <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> ans = to_string(sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) <span class="built_in">cout</span> &lt;&lt; num[ans[i] - <span class="string">'0'</span>] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-445-数字反转"><a href="#Acwing-445-数字反转" class="headerlink" title="Acwing 445. 数字反转"></a><a href="https://www.acwing.com/problem/content/447/" target="_blank" rel="noopener">Acwing 445. 数字反转</a></h2><p>直接模拟, 注意负号和前导0的处理</p>
<h3 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 做法一 直接逆序输出 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    string s; cin &gt;&gt; s;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    while (s.back() == '0') s.pop_back();</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    bool flag = s[0] == '-';</span></span><br><span class="line"><span class="comment">    if (flag) cout &lt;&lt; '-';</span></span><br><span class="line"><span class="comment">    for (int i = s.size() - 1; i &gt; 0; --i) cout &lt;&lt; s[i];</span></span><br><span class="line"><span class="comment">    if (!flag) cout &lt;&lt; s[0];</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* 做法二 逆序处理再输出 */</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) n = -n, <span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; n; n /= <span class="number">10</span>) &#123;</span><br><span class="line">        ans = ans * <span class="number">10</span> + n % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-449-质因数分解"><a href="#Acwing-449-质因数分解" class="headerlink" title="Acwing 449. 质因数分解"></a><a href="https://www.acwing.com/problem/content/451/" target="_blank" rel="noopener">Acwing 449. 质因数分解</a></h2><p>数论题</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>从小到大枚举约数 然后输出大的约数即可<br>理论支持:</p>
<ol>
<li>一个数肯定能被分解成质数乘积的形式</li>
<li>如果一个数能被非质数整除 那这个非质数也能分解成质数乘积 而质数乘积肯定小于非质数本身</li>
<li>因为是从小到大枚举 再加上第2点 不可能枚举到能分解成质数乘积的非质数</li>
</ol>
<h3 id="参考代码-7"><a href="#参考代码-7" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; ; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(n % i)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; n / i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Acwing-441-数字统计"><a href="#Acwing-441-数字统计" class="headerlink" title="Acwing 441. 数字统计"></a><a href="https://www.acwing.com/problem/content/443/" target="_blank" rel="noopener">Acwing 441. 数字统计</a></h2><h3 id="模拟-枚举"><a href="#模拟-枚举" class="headerlink" title="模拟 + 枚举"></a>模拟 + 枚举</h3><p>数字求和, 求某个数字的个数等等, 都是枚举数字的每一位<br>直接用模板即可<br>时间复杂度 $O(NlogN)$</p>
<h3 id="参考代码-8"><a href="#参考代码-8" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTwo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x /= <span class="number">10</span>) &#123;</span><br><span class="line">        ret += x % <span class="number">10</span> == <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) cnt += getTwo(i);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-458-比例简化"><a href="#Acwing-458-比例简化" class="headerlink" title="Acwing 458. 比例简化"></a><a href="https://www.acwing.com/problem/content/460/" target="_blank" rel="noopener">Acwing 458. 比例简化</a></h2><p>标签上写着二分, 想了个双重二分放弃, 直接暴力双重循环(doge</p>
<h3 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h3><p>直接枚举并按照条件筛选最优解<br>不过这里有个优化, 不用判断是否互质, 可以使用一下反证法<br>因为我们是从小到大枚举, 如果存在 $gcd(A_1, B_1) = C \enspace != 1$, 且 $A_1, B_1$ 的比例最接近原来的比例<br>那么一定可以通过约去公约数, 得到新的两个数, 这两个数互质且也最接近原来的比例<br>即 $(A_1 / C) / (B_1 / C) = A_2 / B_2$, $gcd(A_2, B_2) = 1$ 且 $A_2, B_2$ 的比例也最接近原来的比例<br>显然$A_2, B_2$ 是小于 $A_1, B_1$的, 也就是说会提前枚举到, 因此我们取到的答案肯定是互质的<br>时间复杂度 $O(N^2)$</p>
<h3 id="参考代码-9"><a href="#参考代码-9" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A, B, L;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">double</span> delta = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">double</span> X = A * <span class="number">1.0</span> / B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= L; j ++ ) &#123;</span><br><span class="line">            <span class="keyword">double</span> x = i * <span class="number">1.0</span> / j;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= X &amp;&amp; x - X &lt; delta) &#123;</span><br><span class="line">                delta = x - X;</span><br><span class="line">                a = i, b = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">' '</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-425-明明的随机数"><a href="#Acwing-425-明明的随机数" class="headerlink" title="Acwing 425. 明明的随机数"></a><a href="https://www.acwing.com/problem/content/427/" target="_blank" rel="noopener">Acwing 425. 明明的随机数</a></h2><p>经典桶排序, 可以当作模板了</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>严格来说这是计数排序, 不是桶排序<br>空间换时间的一种应用, 开一个长度和最大数据相同的数组<br>然后把数据当作索引, 数组的值用来记录数据出现的次数<br>最后直接遍历这个数组, 数组值不为0就说明有这个数据<br>输出即是排序好的数据</p>
<h3 id="参考代码-10"><a href="#参考代码-10" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (!cnt[t]) ++m, cnt[t] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 骚操作版本 利用位运算消除if */</span></span><br><span class="line">        <span class="comment">// m += !cnt[t] &amp; 1;</span></span><br><span class="line">        <span class="comment">// cnt[t] = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i]) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-417-不高兴的津津"><a href="#Acwing-417-不高兴的津津" class="headerlink" title="Acwing 417. 不高兴的津津"></a><a href="https://www.acwing.com/problem/content/419/" target="_blank" rel="noopener">Acwing 417. 不高兴的津津</a></h2><p>今天也是一道<del>水题</del>模拟呢</p>
<h3 id="参考代码-11"><a href="#参考代码-11" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>, day;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> t = a + b;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; t) ans = t, day = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans &gt; <span class="number">8</span> ? day : <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-421-陶陶摘苹果"><a href="#Acwing-421-陶陶摘苹果" class="headerlink" title="Acwing 421. 陶陶摘苹果"></a><a href="https://www.acwing.com/problem/content/423/" target="_blank" rel="noopener">Acwing 421. 陶陶摘苹果</a></h2><p>难得出现一道水题, 估计是在给后面的题目铺垫</p>
<h3 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h3><p>直接按照题目要求, 进行模拟即可</p>
<h3 id="参考代码-12"><a href="#参考代码-12" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> init; <span class="built_in">cin</span> &gt;&gt; init;</span><br><span class="line">    init += <span class="number">30</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) ans += init &gt;= a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-428-数列"><a href="#Acwing-428-数列" class="headerlink" title="Acwing 428. 数列"></a><a href="https://www.acwing.com/problem/content/430/" target="_blank" rel="noopener">Acwing 428. 数列</a></h2><h3 id="二进制枚举-快速幂"><a href="#二进制枚举-快速幂" class="headerlink" title="二进制枚举 + 快速幂"></a>二进制枚举 + 快速幂</h3><p>仔细观察数列，可以发现第 $n$ 项的公式和 $n$ 的二进制位有关<br>因此直接枚举二进制的每一位，然后求幂的时候使用快速幂即可<br>时间复杂度 $O(klog(n))$</p>
<h3 id="参考代码-13"><a href="#参考代码-13" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret *= a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a *= a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//枚举每一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; n; ++i) &#123;</span><br><span class="line">        <span class="comment">//如果为1说明需要进行运算</span></span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans += <span class="built_in">get</span>(k, i);</span><br><span class="line">        <span class="comment">//左移准备处理下一位</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-433-ISBN号码"><a href="#Acwing-433-ISBN号码" class="headerlink" title="Acwing 433. ISBN号码"></a><a href="https://www.acwing.com/problem/content/435/" target="_blank" rel="noopener">Acwing 433. ISBN号码</a></h2><h3 id="字符串处理-模拟"><a href="#字符串处理-模拟" class="headerlink" title="字符串处理 + 模拟"></a>字符串处理 + 模拟</h3><p>直接根据题意，对字符串进行处理即可</p>
<h3 id="参考代码-14"><a href="#参考代码-14" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = s[<span class="number">0</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        sum += (s[i] - <span class="string">'0'</span>) * cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">6</span>; i &lt; <span class="number">11</span>; ++i) &#123;</span><br><span class="line">        sum += (s[i] - <span class="string">'0'</span>) * cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    sum %= <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">char</span> goal = sum == <span class="number">10</span> ? <span class="string">'X'</span> : sum + <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (goal == s[<span class="number">12</span>]) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Right"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s[<span class="number">12</span>] = goal;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acwing-89-a-b"><a href="#Acwing-89-a-b" class="headerlink" title="Acwing 89. a^b"></a><a href="https://www.acwing.com/problem/content/91/" target="_blank" rel="noopener">Acwing 89. a^b</a></h2><h3 id="暴力运算"><a href="#暴力运算" class="headerlink" title="暴力运算"></a>暴力运算</h3><p>直接循环计算，时间复杂度 $O(n)$<br>缺点：当幂数过大容易超时</p>
<h4 id="参考代码-15"><a href="#参考代码-15" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b--) &#123;</span><br><span class="line">        ret = <span class="number">1L</span>L * ret * a % p;</span><br><span class="line">        a = <span class="number">1L</span>L * a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>利用二进制思想，转化为加权运算，减少不必要的运算，时间复杂度$O(log_2(n))$</p>
<h4 id="参考代码-16"><a href="#参考代码-16" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = <span class="number">1L</span>L * ret * a % p;</span><br><span class="line">        a = <span class="number">1L</span>L * a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo next主题 更新社交链接图标 引入iconfont阿里巴巴矢量图标库</title>
    <url>/archives/3753999883/</url>
    <content><![CDATA[<p>简简单单 在博客主题的自定义css文件引入图标链接即可 记得CTRL+F5刷新哦</p>
<a id="more"></a>

<h2 id="找到图标下单"><a href="#找到图标下单" class="headerlink" title="找到图标下单"></a>找到图标下单</h2><p>进入<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">阿里巴巴矢量图标库</a><br>搜索图标，加入购物车，在购物车中选择添加至项目，如果没有则新建一个。</p>
<h2 id="生成图标链接"><a href="#生成图标链接" class="headerlink" title="生成图标链接"></a>生成图标链接</h2><p>进入项目，选择<code>Font Class</code>选项，点击<code>查看在线链接</code><br>复制链接到浏览器地址栏打开，复制网页内容，大概是这个样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@font-face &#123;&#125;</span><br><span class="line">.iconfont &#123;&#125;</span><br><span class="line">.xxx:before &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找到主题的自定义css文件"><a href="#找到主题的自定义css文件" class="headerlink" title="找到主题的自定义css文件"></a>找到主题的自定义css文件</h2><p>配置文件路径 <code>\themes\next\source\css\_custom\custom.styl</code><br>如果没有则新建一个，然后把内容粘贴进去，可做适当修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># xxx是在主题配置文件使用图标要用到的图标名 可修改成自己想要的</span><br><span class="line">.xxx:before &#123;&#125;</span><br><span class="line"># 比如我改成gitee</span><br><span class="line">.gitee:before &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改主题的配置文件"><a href="#修改主题的配置文件" class="headerlink" title="修改主题的配置文件"></a>修改主题的配置文件</h2><p>在主题的配置文件中找到<code>social</code>选项<br>按照如下格式配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  # 自定义社交链接名称: 个人主页链接 || custom 图标名</span><br><span class="line">  Gitee: https:&#x2F;&#x2F;gitee.com&#x2F;insight21 || custom gitee</span><br></pre></td></tr></table></figure>

<p>到此就把社交链接图标更新完啦！如果有疑惑可以联系我！</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo博客多线部署 GitHub Gitee Coding 云服务器</title>
    <url>/archives/3039932550/</url>
    <content><![CDATA[<p>结论：有钱直接上云服务器 没钱不在乎自定义域名就部署国内 否则只能GitHub</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花了一个下午折腾多线部署，以及域名解析<br>到最后一场空 老老实实回GitHub :(<br>第二天还是选择部署到服务器了<br>PS：服务器和域名最好买同一家的，备案比较方便</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>GitHub: 除了慢 什么都好</li>
<li>Gitee &amp; Coding: 速度快 但是如果想要绑定好看的自定义域名 就需要氪金<ul>
<li>Gitee: 需要手动更新 无法绑定自定义域名</li>
<li>Coding: 国内节点绑定域名需要备案 (如果不选择国内节点 那就没意义了)</li>
</ul>
</li>
<li>云服务器: 可以考虑 首次配置麻烦点 需要续费和<a href="https://baike.baidu.com/item/ICP%E5%A4%87%E6%A1%88/1220667?fr=aladdin" target="_blank" rel="noopener">ICP备案</a></li>
</ul>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><code>git</code> + <code>hexo</code><br>hexo博客的本地部署，请参考其他文章<br>本文具体讲本地已经可以运行的博客，如何部署到静态页面+服务器<br>静态页面的部署大同小异，服务器会多些步骤</p>
<h2 id="关于公钥"><a href="#关于公钥" class="headerlink" title="关于公钥"></a>关于公钥</h2><blockquote>
<p>可以一个公钥部署所有仓库，但是这样不安全，相当于一把钥匙开所有保险库，而且公钥一旦变动，所有仓库都需要更新。<br>因此先介绍多仓库多公钥的使用。</p>
</blockquote>
<h3 id="如何生成公钥"><a href="#如何生成公钥" class="headerlink" title="如何生成公钥"></a>如何生成公钥</h3><p>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen [-C comment] [-f output_keyfile] [-t dsa | ecdsa | ecdsa-sk | ed25519 | ed25519-sk | rsa]</span><br></pre></td></tr></table></figure>
<p>其中<br>-C 添加注释 一般是自己的邮箱<br>-f 指定公钥保存文件 默认保存到<code>C:\Users\username\.ssh\id_xxx.pub</code><br>-t 指定公钥生成算法 一般选择<code>rsa</code>或者<code>dsa</code></p>
<p>除此之外，生成公钥时还可以指定公钥的密码，当你输入命令后，会出现以下提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;c&#x2F;Users&#x2F;Learner&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>
<p>你可以<strong>直接回车不设置密码</strong>，这样登录服务器或者推送到仓库时，就不用再输入一次密码；<br>也可以设置密码，这样就相当于<code>公钥</code>+<code>密码</code>双重组合保护</p>
<p>举个例子，用自己的邮箱，使用<code>rsa</code>算法生成公钥保存到<code>github_rsa.pub</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;10086@qq.com&quot; -f C:\Users\username\.ssh\github_rsa.pub</span><br></pre></td></tr></table></figure>
<p>然后我选择不设置密码，一路回车，最后<strong>使用编辑器打开</strong><code>github_rsa.pub</code>文件，查看公钥内容。</p>
<h3 id="多个公钥的配置文件"><a href="#多个公钥的配置文件" class="headerlink" title="多个公钥的配置文件"></a>多个公钥的配置文件</h3><p>文件路径<br><code>C:\Users\username\.ssh\config</code><br><code>username</code>为自己的电脑用户名</p>
<p>如果没有需要新建 注意<strong>没有后缀名</strong><br>需要把ssh整个文件夹的<strong>权限修改成当前用户</strong></p>
<p>文件格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">Hostname github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;***</span><br></pre></td></tr></table></figure>
<p><code>Host</code>和<code>Hostname</code>替换成自己的服务器IP或者仓库位置<br><code>IdentityFile</code>替换成自己的公钥文件路径</p>
<p>以我的配置文件示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#github</span><br><span class="line">Host github.com</span><br><span class="line">Hostname github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;git_id_rsa</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>可以输入以下命令进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T 用户名@代码仓库网站或者服务器IP</span><br></pre></td></tr></table></figure>
<p>比如测试GitHub，用户名默认为<code>git</code>，网站为<code>github.com</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">Hi insight-21! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>出现类似内容即为连接成功，如果出现拒绝访问，请检查以上步骤是否正确。</p>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><ol>
<li><p>添加SSH公钥<br>在账户设置页面，左侧选项卡下拉找到<code>SSH and GPG keys</code><br>右侧点击<code>New SSH key</code>，把你的公钥内容复制进去，点击<code>Add SSH key</code>即可</p>
</li>
<li><p>创建仓库<br>新建仓库，名为<code>你的github用户名.github.io</code><br>按照格式来，这样就可以通过仓库名称在网页访问你的Blog<br>注意：<code>Add a README file</code> <code>Add .gitignore</code>这两个不要点，要不然等一下上传文件<strong>可能会因为仓库差异拒绝合并</strong></p>
</li>
<li><p>添加仓库地址到_config.yml<br>创建完成后，在仓库页面，点击绿色的<code>Code</code>按钮，复制仓库的<code>SSH</code>链接，来到你的博客根目录，打开<code>_config.yml</code>，下拉找到如下配置或者自己添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: </span><br><span class="line">  repo: </span><br><span class="line">  branch:</span><br></pre></td></tr></table></figure>
<p>修改成以下样式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">    github: git@github.com:insight-21&#x2F;insight-21.github.io.git</span><br><span class="line">    gitee: git@gitee.com:insight21&#x2F;insight21.git</span><br><span class="line">    coding: git@e.coding.net:insight21&#x2F;insight21-blog&#x2F;insight21.coding.me.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>其中，repo(仓库)下可以配置多个仓库地址，具体格式为<code>自定义名称: 仓库的SSH地址</code>，随后的<code>Gitee</code>、<code>Coding</code>和<code>服务器</code>也是如此配置。<br>接着执行上传命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>上传完成后，刷新页面查看仓库是否变化</p>
</li>
<li><p>在仓库设置中添加个人域名<br>在仓库页面，点击<code>Setting</code>，下拉找到<code>GitHub Pages</code>，在<code>Custom domain</code>中填写你的域名，并且勾选使用<code>HTTPS</code>协议</p>
</li>
</ol>
<ul>
<li><input checked="" disabled="" type="checkbox"> <code>Enforce HTTPS</code></li>
</ul>
<h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><ol>
<li><p>添加SSH公钥<br><a href="#GitHub">与GitHub的步骤相同</a>，在个人账号设置里添加</p>
</li>
<li><p>创建一个<strong>与用户名相同</strong>的仓库<br><a href="https://gitee.com/help/articles/4136" target="_blank" rel="noopener">官方解释</a><br>这样可以创建一个首页访问地址不带二级目录的静态页面</p>
</li>
<li><p>添加仓库地址到_config.yml<br><a href="#GitHub">与GitHub的步骤相同</a></p>
</li>
<li><p>部署静态页面 以及<strong>记得手动更新</strong><br>在仓库页面，点击<code>服务</code>，选择<code>Gitee Pages</code>，选择<code>强制使用HTTPS</code>，点击<code>启动</code>，等待部署完成，即可点击给出的链接访问博客</p>
</li>
</ol>
<h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><blockquote>
<p>Coding自从改版后，很多操作都不同了</p>
</blockquote>
<ol>
<li><p>创建团队、项目和仓库<br>Coding要求你<strong>先创建团队</strong>，然后才能使用各种功能<br>接着创建一个项目，模板选择<code>DevOps</code>，因为只有它能部署静态页面<br>然后在项目页面，左侧选择创建一个代码仓库<br>和前面不同，项目和仓库的名字可以随便取</p>
</li>
<li><p>添加SSH公钥<br><a href="#GitHub">与GitHub的步骤相同</a>，在个人账号设置里添加</p>
</li>
<li><p>添加仓库地址到_config.yml<br><a href="#GitHub">与GitHub的步骤相同</a></p>
</li>
<li><p>部署静态页面<br>在项目页面左侧的<code>持续部署</code>中选择<code>静态网站</code>，需要绑定腾讯云账号，授权、实名认证然后才能部署(因为Coding被马先生全资收购了)<br>这样需要注意一下，<strong>网站的节点选择</strong>，如果选择香港，速度是很慢的，那就失去了部署在国内代码仓库的意义了，因为我们本来就是为了提高速度才来这里的；选择国内节点，绑定个人域名要求域名备案。<br>部署完成后，点击进去可看到静态页面的网站地址。</p>
</li>
</ol>
<h2 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h2><ol>
<li><p>添加SSH公钥<br>我的服务器系统是<code>Ubuntu16.04</code>，公钥保存文件路径为<code>当前用户/.ssh/authorized_keys</code>，其他系统应该差不多，如果没有则自行创建一个，然后把公钥保存进去即可。<br>记得远程连接一下服务器，看看登录是不是不需要用户密码了。</p>
</li>
<li><p>安装Git和Nginx<br>首先更新一下软件源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<p>然后安装<code>git</code>和<code>nginx</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get git</span><br><span class="line">sudo apt-get nginx</span><br></pre></td></tr></table></figure>
<p><code>nginx</code>安装后应该是启动了，命令查看一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service nginx status</span><br></pre></td></tr></table></figure>
<p>如果没有就启动一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建仓库和GitHook</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;home&#x2F;insight&#x2F;gitRepo #新建目录，这是git仓库的位置</span><br><span class="line">sudo mkdir pp &#x2F;home&#x2F;insight&#x2F;www&#x2F;hexo #用于保存nginx的网站文件</span><br><span class="line">cd &#x2F;home&#x2F;insight&#x2F;gitRepo  #转到git仓库的文件夹</span><br><span class="line">sudo git init --bare blog.git #创建一个名叫blog的仓库</span><br><span class="line">sudo vim &#x2F;hooks&#x2F;post-update #创建一个钩子(hook)来实现自动化部署到nginx的网站文件夹</span><br><span class="line">#输入以下内容</span><br><span class="line">rm -rf &#x2F;home&#x2F;insight&#x2F;www&#x2F;hexo</span><br><span class="line">git clone &#x2F;home&#x2F;insight&#x2F;gitRepo&#x2F;blog.git &#x2F;home&#x2F;insight&#x2F;www&#x2F;hexo</span><br></pre></td></tr></table></figure>
<p>不要忘记给钩子<strong>添加可执行权限</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod u+x &#x2F;home&#x2F;insight&#x2F;gitRepo&#x2F;blog.git&#x2F;hooks&#x2F;*</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Nginx配置文件<br>先说明一下，我的系统上，nginx的配置文件的结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf #这是自带的(替身使者)默认配置文件</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;conf.d #这是其他的自定义配置文件</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;sites-enabled #软链接到sites-available</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;sites-available #这才是真正的详细的默认配置</span><br></pre></td></tr></table></figure>
<p>在<code>/etc/nginx/nginx.conf</code>的后半部分可以看到这两句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">include &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;*;</span><br></pre></td></tr></table></figure>
<p>说明其实<code>nginx.conf</code>只是单纯的包含其他配置文件，因此需要去<code>/conf.d</code>下自定义配置文件或者去<code>/sites-available</code>中修改默认配置，在这里我为了省事直接修改默认配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  #默认端口可以不修改</span><br><span class="line">  listen 80 default_server;</span><br><span class="line">  listen [::]:80 default_server;</span><br><span class="line">  #根目录 为前文所创建的网站文件夹</span><br><span class="line">  root &#x2F;home&#x2F;insight&#x2F;www&#x2F;hexo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改完成后，记得检查一下，看是否有错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br><span class="line">nginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful</span><br></pre></td></tr></table></figure>
<p>然后重载一下nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改服务器安全组策略<br>最后别忘记去服务器控制台，修改安全组策略，开放80端口访问博客。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此，自己的博客终于搭建起来啦！</p>
<p>没想到一个博客折腾了我两天（吐血</p>
<p>总的来说，部署到云服务器是最好的选择了，速度快，可以绑定域名，顺带练习Linux命令，真是棒极了呢（苦瓜脸</p>
<p>不过要是GitHub能正常使用，谁会闲得去折腾呢（反正我不会</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title>竞赛模板</title>
    <url>/archives/4279424088/</url>
    <content><![CDATA[<p>竞赛自用模板，放在博客当备份，方便取用。</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pi acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in(x) int (x);cin &gt;&gt; (x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LoopIn(Loop_var) in(Loop_var);while(Loop_var--) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Loop(i, X, N) for(int i = X; i &lt; N; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IOS</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Codes</category>
      </categories>
  </entry>
  <entry>
    <title>常用代码模板</title>
    <url>/archives/3153460496/</url>
    <content><![CDATA[<p>收集各种基础算法的通用模板，持续更新中。</p>
<a id="more"></a>

<p>模板来自AcWing y总。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>最常用的排序，快速排序，属于交换类排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>; <span class="comment">//递归结束条件 划分到只剩下一个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = a[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>; <span class="comment">//选定比较数的方法还有很多</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (a[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j++; <span class="keyword">while</span> (a[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    qSort(a, l, j), qSort(a, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快排日常已经够用了，但也有不能满足需要的时候，比如求逆序对，这个时候就要用到归并排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>; <span class="comment">//递归结束条件 划分到只剩下一个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(a, l, mid);</span><br><span class="line">    mergeSort(a, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> t[N];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//对一分为二的数组 进行比较 然后拷贝到临时数组里面</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;    </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j]) t[index++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> t[index++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个数组可能还有剩余 这时直接把剩下的全拷贝过去</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) t[index++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) t[index++] = a[j++];</span><br><span class="line">    <span class="comment">//最后拷贝已经有序临时数组 </span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) a[i] = t[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>要求已有数据为有序状态。<br>$$</p>
<p>$$<br><strong>整数二分和浮点数二分的区别是</strong></p>
<ol>
<li><p><strong>循环结束条件的写法</strong></p>
</li>
<li><p><strong>浮点数不能使用位运算</strong></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">     mid = (r - l) &gt;&gt; <span class="number">1</span> + l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浮点数 </span></span><br><span class="line"><span class="comment">//因为浮点数会有精度损失问题 所以使用这样的比较写法</span></span><br><span class="line"><span class="comment">//1e-n 保留 n 位小数 保险起见可以多加一位</span></span><br><span class="line"><span class="keyword">while</span> (r - l &lt; <span class="number">1</span>e-n) &#123;</span><br><span class="line">    mid = (r - l) / <span class="number">2.0</span> + l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>划分的区间为 [l, mid]，[mid + 1, r] 时，一般用途求最小化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//划分的区间为[l, mid]，[mid + 1, r]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (r - l) &gt;&gt; <span class="number">1</span> + l; <span class="comment">//防止溢出 好习惯 从我做起</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>划分的区间为 [l, mid - 1]，[mid, r] 时，一般用途求最大化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//划分的区间为[l, mid - 1]，[mid, r]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (r - l + <span class="number">1</span>) &gt;&gt; <span class="number">1</span> + l; <span class="comment">//需要额外加1 防止死循环</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你对区间的划分和对应的二分记不清楚的话，我这里提供一个我自己的小技巧</p>
<ol>
<li>求最大化，右边比左边大，那 mid 就在右区间，而 mid 的左边 mid - 1 就是左区间，即[l, mid - 1]，[mid, r]；</li>
<li>求最小化，左边比右边小，那 mid 就在左区间，而 mid 的右边 mid + 1 就是右区间，即[l, mid]，[mid + 1, r]。</li>
<li>另外，如果只是单纯查找一个数，两个模板都可以用，或者使用最朴素的二分查找。</li>
</ol>
<h2 id="大数加减乘除"><a href="#大数加减乘除" class="headerlink" title="大数加减乘除"></a>大数加减乘除</h2><p>当运算数连 long long 都保存不了，就使用字符串或者整型数组来处理这类问题。</p>
<p>加法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//123 在vector中为321 逆序存放</span></span><br><span class="line"><span class="comment">//&amp; 运算符可以加快传参速度</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用大数 + 小数的方式</span></span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> add(B, A);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//保存加法进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">//不断进行末位相加 结果是余数 进位不断前进</span></span><br><span class="line">        carry += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) carry += B[i];</span><br><span class="line">        ret.push_back(carry % <span class="number">10</span>);</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果最后还有进位 就加进去</span></span><br><span class="line">    <span class="keyword">if</span> (carry) ret.push_back(carry);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>减法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//与加法同理</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        carry = A[i] - carry;<span class="comment">//如果有借位 就减掉</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) carry -= B[i];</span><br><span class="line">        ret.push_back((carry + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//每次借位只有0 或 1两种情况</span></span><br><span class="line">        <span class="keyword">if</span> (carry &lt; <span class="number">0</span>) t = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//消除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (ret.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ret.back() == <span class="number">0</span>) ret.pop_back();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乘法</p>
<ul>
<li><input disabled="" type="checkbox"> 大数和大数乘法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先是大数与一位数的乘法 再扩展到大数与大数的乘法</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mulSingle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        ret.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消除前导0 比如123 可能逆序存放为3210</span></span><br><span class="line">    <span class="keyword">while</span> (ret.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ret.back() == <span class="number">0</span>) ret.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除法</p>
<ul>
<li><input disabled="" type="checkbox"> 大数与大数除法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A 被除数 b 除数 r 余数</span></span><br><span class="line"><span class="comment">//一般情况除数不会爆数据类型 使用普通除法就行</span></span><br><span class="line"><span class="comment">//极限情况的大数与大数除法 需要别的思路 还没有写好...</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div_1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        ret.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (ret.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ret.back() == <span class="number">0</span>) ret.pop_back();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="因数个数与因数之和"><a href="#因数个数与因数之和" class="headerlink" title="因数个数与因数之和"></a>因数个数与因数之和</h2><h3 id="因数个数"><a href="#因数个数" class="headerlink" title="因数个数"></a>因数个数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因数个数</span></span><br><span class="line"><span class="comment">//原理: 每个质因子的最高次方+1的连乘</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>, res = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    Loop(i, <span class="number">2</span>, x) &#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans *= (res + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="因数之和"><a href="#因数之和" class="headerlink" title="因数之和"></a>因数之和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因数之和</span></span><br><span class="line"><span class="comment">//原理: 每个质因子从0次方加到它的最高次方，然后连乘。</span></span><br><span class="line"><span class="comment">//比如：求18 ，（2^0 + 2)*(3^0+3+3^2) = 3*13 = 39 </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>, res = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    Loop(i, <span class="number">2</span>, x) &#123;</span><br><span class="line">        res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res *= i;</span><br><span class="line">            x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = (res * i - <span class="number">1</span>) / (i - <span class="number">1</span>);</span><br><span class="line">        ans *= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="究极位运算用法收集"><a href="#究极位运算用法收集" class="headerlink" title="究极位运算用法收集"></a>究极位运算用法收集</h2>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>书单</title>
    <url>/archives/3902883597/</url>
    <content><![CDATA[<p>心血来潮想要记录一下个人书单，同时也是一个个人学习路线，挂在博客当达摩克利斯之剑。</p>
 <a id="more"></a> 

<blockquote>
<p>黑色标粗，是想要着重看的；</p>
<p>标号，代表想要阅读的次序。</p>
</blockquote>
<h3 id="计算机基础书籍-面试基础"><a href="#计算机基础书籍-面试基础" class="headerlink" title="计算机基础书籍  |  面试基础"></a>计算机基础书籍  |  面试基础</h3><ol>
<li>数据结构和算法分析 [美] Mark Allen Weiss</li>
<li>操作系统 </li>
<li>计算机组成原理</li>
<li><strong>计算机网络：自顶向下</strong></li>
<li><strong>TCP / IP详解</strong></li>
</ol>
<h3 id="算法和竞赛书籍"><a href="#算法和竞赛书籍" class="headerlink" title="算法和竞赛书籍"></a>算法和竞赛书籍</h3><ol>
<li><strong>算法竞赛入门经典</strong> [中]刘汝佳 （紫 蓝 绿三本书）</li>
<li>算法设计与分析/算法设计手册</li>
<li>挑战程序设计竞赛 [日] 秋叶拓哉  岩田阳一  北川宜稔 <del>（大概率不读）</del></li>
</ol>
<h3 id="Java-基础书籍"><a href="#Java-基础书籍" class="headerlink" title="Java 基础书籍"></a>Java 基础书籍</h3><ol>
<li><strong>Java核心实用技术卷一 、二</strong></li>
<li><strong>Java编程思想 thinking in java</strong></li>
<li><strong>深入理解Java虚拟机</strong></li>
</ol>
<h3 id="JavaEE-开发框架"><a href="#JavaEE-开发框架" class="headerlink" title="JavaEE  |  开发框架"></a>JavaEE  |  开发框架</h3><ol>
<li><strong>Spring Boot 实战</strong> （强烈推荐，目前主流框架）</li>
<li>Spring实战 （学完Spring Boot 回来看Spring）</li>
<li>Spring揭秘</li>
</ol>
<h3 id="Java-提升修炼"><a href="#Java-提升修炼" class="headerlink" title="Java 提升修炼"></a>Java 提升修炼</h3><ol>
<li>Java并发实战</li>
<li>Java并发编程的艺术</li>
<li>OnJava8</li>
<li>Effective Java</li>
<li>重构 改善既有代码设计</li>
<li>函数编程思维</li>
<li>JDK源码阅读</li>
<li>阿里巴巴Java开发手册</li>
</ol>
<h3 id="零食"><a href="#零食" class="headerlink" title="零食"></a>零食</h3><ol>
<li>浪潮之巅</li>
<li>代码整洁之道</li>
<li>程序员的职业素养</li>
</ol>
<p>最后留一句，大学毕业前能看到Spring Boot 算我🐂🍺。</p>
]]></content>
      <categories>
        <category>Books</category>
      </categories>
  </entry>
  <entry>
    <title>My First archive</title>
    <url>/archives/2043672006/</url>
    <content><![CDATA[<p>文章测试</p>
<p>$$<br>\pi = \frac a b<br>$$</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
</search>
