<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Acwing寒假每日一题(提高组) 打卡记录 题解</title>
    <url>/archives/465097960/</url>
    <content><![CDATA[<p>寒假组队学习算法，闫老师带领大家每日刷一道经典算法题。<br>题目难度：中等偏上，题目选自CodeForces、ACM、NOIP、蓝桥杯等比赛真题。<br><a href="https://www.acwing.com/user/myspace/index/34956/" target="_blank" rel="noopener">欢迎来Acwing围观我</a></p>
<a id="more"></a>

<h2 id="AcWing-125-耍杂技的牛"><a href="#AcWing-125-耍杂技的牛" class="headerlink" title="AcWing 125. 耍杂技的牛"></a><a href="https://www.acwing.com/problem/content/127/" target="_blank" rel="noopener">AcWing 125. 耍杂技的牛</a></h2><p>与 <a href="https://www.acwing.com/problem/content/116/" target="_blank" rel="noopener">AcWing 114. 国王游戏</a> 相同套路的一道题</p>
<h3 id="排序-贪心"><a href="#排序-贪心" class="headerlink" title="排序 + 贪心"></a>排序 + 贪心</h3><p>时间复杂度 $O(nlog(n))$<br>做法：按照牛的重量与强壮程度之和 $W_i + S_i$ 排序，得到的便是最优做法。</p>
<p>证明：<br>第 $i$ 头牛的危险程度： $\displaystyle\sum_{j=1}^{i - 1}{W_j} - S_i$</p>
<p>接下来列出两头牛在位置顺序交换前后的危险程度</p>
<table>
<thead>
<tr>
<th>牛</th>
<th>交换前</th>
<th>交换后</th>
</tr>
</thead>
<tbody><tr>
<td>$i$</td>
<td>$\displaystyle\sum_{j=1}^{i - 1}{W_j} - S_i$</td>
<td>$\displaystyle\sum_{j=1}^{i - 1}{W_j} + W_{i+1} - S_i$</td>
</tr>
<tr>
<td>$i + 1$</td>
<td>$\displaystyle\sum_{j=1}^{i}{W_j} - S_{i+1}$</td>
<td>$\displaystyle\sum_{j=1}^{i-1}{W_j} - S_{i+1}$</td>
</tr>
</tbody></table>
<p>化简式子，减去$\displaystyle\sum_{j=1}^{i-1}{W_j}$</p>
<table>
<thead>
<tr>
<th>牛</th>
<th>交换前</th>
<th>交换后</th>
</tr>
</thead>
<tbody><tr>
<td>$i$</td>
<td>$- S_i (a)$</td>
<td>$W_{i+1} - S_i (b)$</td>
</tr>
<tr>
<td>$i + 1$</td>
<td>$W_i - S_{i+1} (c)$</td>
<td>$- S_{i+1} (d)$</td>
</tr>
</tbody></table>
<p>首先，明显 $a &lt; b, d &lt; c$<br>所以如果能得出 $b$ 和 $c$ 的关系，就能比较交换前后危险程度的大小<br>当 $W_{i+1} - S_i$ &gt;= $W_i - S_{i+1}$，移项变成$W_{i+1} + S_{i+1}$ &gt;= $W_i + S_i$，交换前的危险程度更小<br>当 $W_{i+1} - S_i$ &lt; $W_i - S_{i+1}$，移项变成$W_{i+1} + S_{i+1}$ &lt; $W_i + S_i$，交换前后的危险程度更小</p>
<p>可知交换前后的危险程度和 $W_i + S_i$ 有关，到此证毕。</p>
<p>具体做法：根据 $W_i + S_i$ 排序，然后枚举记录更大的危险程度，输出即可。</p>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line">pii a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> w, s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="comment">//因为sort函数是按照数组第一维来排序的</span></span><br><span class="line">        <span class="comment">//为了方便排序 直接把数组第一维变成两者之和</span></span><br><span class="line">        a[i] = &#123;w + s, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-0x3f3f3f3f</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = a[i].second, s = a[i].first - w;</span><br><span class="line">        <span class="comment">//记录更大的危险程度 重量减去强壮程度</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, sum - s);</span><br><span class="line">        <span class="comment">//计算重量之和</span></span><br><span class="line">        sum += w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Acwing寒假每日一题(入门组) 打卡记录 题解</title>
    <url>/archives/2940978202/</url>
    <content><![CDATA[<p>寒假组队学习算法，闫老师带领大家每日刷一道经典算法题。<br>题目难度：入门级别。<br><a href="https://www.acwing.com/user/myspace/index/34956/" target="_blank" rel="noopener">欢迎来Acwing围观我</a></p>
<a id="more"></a>

<h2 id="Acwing-89-a-b"><a href="#Acwing-89-a-b" class="headerlink" title="Acwing 89. a^b"></a><a href="https://www.acwing.com/problem/content/91/" target="_blank" rel="noopener">Acwing 89. a^b</a></h2><h3 id="暴力运算"><a href="#暴力运算" class="headerlink" title="暴力运算"></a>暴力运算</h3><p>直接循环计算，时间复杂度 $O(n)$<br>缺点：当幂数过大容易超时</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b--) &#123;</span><br><span class="line">        ret = <span class="number">1L</span>L * ret * a % p;</span><br><span class="line">        a = <span class="number">1L</span>L * a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>利用二进制思想，转化为加权运算，减少不必要的运算，时间复杂度$O(log_2(n))$</p>
<h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = <span class="number">1L</span>L * ret * a % p;</span><br><span class="line">        a = <span class="number">1L</span>L * a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>更新Hexo侧边社交链接图标 引入iconfont阿里巴巴矢量图标库</title>
    <url>/archives/3753999883/</url>
    <content><![CDATA[<p>简简单单 在博客主题的自定义css文件引入图标链接即可 记得CTRL+F5刷新哦</p>
<a id="more"></a>

<h2 id="找到图标下单"><a href="#找到图标下单" class="headerlink" title="找到图标下单"></a>找到图标下单</h2><h2 id="生成图标链接"><a href="#生成图标链接" class="headerlink" title="生成图标链接"></a>生成图标链接</h2><h2 id="找到主题的自定义css文件"><a href="#找到主题的自定义css文件" class="headerlink" title="找到主题的自定义css文件"></a>找到主题的自定义css文件</h2><h2 id="修改主题的配置文件"><a href="#修改主题的配置文件" class="headerlink" title="修改主题的配置文件"></a>修改主题的配置文件</h2>]]></content>
  </entry>
  <entry>
    <title>Hexo博客多线部署 GitHub Gitee Coding 云服务器</title>
    <url>/archives/3039932550/</url>
    <content><![CDATA[<p>结论：有钱直接上云服务器 没钱不在乎自定义域名就部署国内 否则只能GitHub</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花了一个下午折腾多线部署，以及域名解析<br>到最后一场空 老老实实回GitHub :(<br>第二天还是选择部署到服务器了<br>PS：服务器和域名最好买同一家的，备案比较方便</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>GitHub: 除了慢 什么都好</li>
<li>Gitee &amp; Coding: 速度快 但是如果想要绑定好看的自定义域名 就需要氪金<ul>
<li>Gitee: 需要手动更新 无法绑定自定义域名</li>
<li>Coding: 国内节点绑定域名需要备案 (如果不选择国内节点 那就没意义了)</li>
</ul>
</li>
<li>云服务器: 可以考虑 首次配置麻烦点 需要续费和<a href="https://baike.baidu.com/item/ICP%E5%A4%87%E6%A1%88/1220667?fr=aladdin" target="_blank" rel="noopener">ICP备案</a></li>
</ul>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p><code>git</code> + <code>hexo</code><br>hexo博客的本地部署，请参考其他文章<br>本文具体讲本地已经可以运行的博客，如何部署到静态页面+服务器<br>静态页面的部署大同小异，服务器会多些步骤</p>
<h2 id="关于公钥"><a href="#关于公钥" class="headerlink" title="关于公钥"></a>关于公钥</h2><blockquote>
<p>可以一个公钥部署所有仓库，但是这样不安全，相当于一把钥匙开所有保险库，而且公钥一旦变动，所有仓库都需要更新。<br>因此先介绍多仓库多公钥的使用。</p>
</blockquote>
<h3 id="如何生成公钥"><a href="#如何生成公钥" class="headerlink" title="如何生成公钥"></a>如何生成公钥</h3><p>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen [-C comment] [-f output_keyfile] [-t dsa | ecdsa | ecdsa-sk | ed25519 | ed25519-sk | rsa]</span><br></pre></td></tr></table></figure>
<p>其中<br>-C 添加注释 一般是自己的邮箱<br>-f 指定公钥保存文件 默认保存到<code>C:\Users\username\.ssh\id_xxx.pub</code><br>-t 指定公钥生成算法 一般选择<code>rsa</code>或者<code>dsa</code></p>
<p>除此之外，生成公钥时还可以指定公钥的密码，当你输入命令后，会出现以下提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;c&#x2F;Users&#x2F;Learner&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure>
<p>你可以<strong>直接回车不设置密码</strong>，这样登录服务器或者推送到仓库时，就不用再输入一次密码；<br>也可以设置密码，这样就相当于<code>公钥</code>+<code>密码</code>双重组合保护</p>
<p>举个例子，用自己的邮箱，使用<code>rsa</code>算法生成公钥保存到<code>github_rsa.pub</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;10086@qq.com&quot; -f C:\Users\username\.ssh\github_rsa.pub</span><br></pre></td></tr></table></figure>
<p>然后我选择不设置密码，一路回车，最后<strong>使用编辑器打开</strong><code>github_rsa.pub</code>文件，查看公钥内容。</p>
<h3 id="多个公钥的配置文件"><a href="#多个公钥的配置文件" class="headerlink" title="多个公钥的配置文件"></a>多个公钥的配置文件</h3><p>文件路径<br><code>C:\Users\username\.ssh\config</code><br><code>username</code>为自己的电脑用户名</p>
<p>如果没有需要新建 注意<strong>没有后缀名</strong><br>需要把ssh整个文件夹的<strong>权限修改成当前用户</strong></p>
<p>文件格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">Hostname github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;***</span><br></pre></td></tr></table></figure>
<p><code>Host</code>和<code>Hostname</code>替换成自己的服务器IP或者仓库位置<br><code>IdentityFile</code>替换成自己的公钥文件路径</p>
<p>以我的配置文件示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#github</span><br><span class="line">Host github.com</span><br><span class="line">Hostname github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;git_id_rsa</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>可以输入以下命令进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T 用户名@代码仓库网站或者服务器IP</span><br></pre></td></tr></table></figure>
<p>比如测试GitHub，用户名默认为<code>git</code>，网站为<code>github.com</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">Hi insight-21! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>出现类似内容即为连接成功，如果出现拒绝访问，请检查以上步骤是否正确。</p>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><ol>
<li><p>添加SSH公钥<br>在账户设置页面，左侧选项卡下拉找到<code>SSH and GPG keys</code><br>右侧点击<code>New SSH key</code>，把你的公钥内容复制进去，点击<code>Add SSH key</code>即可</p>
</li>
<li><p>创建仓库<br>新建仓库，名为<code>你的github用户名.github.io</code><br>按照格式来，这样就可以通过仓库名称在网页访问你的Blog<br>注意：<code>Add a README file</code> <code>Add .gitignore</code>这两个不要点，要不然等一下上传文件<strong>可能会因为仓库差异拒绝合并</strong></p>
</li>
<li><p>添加仓库地址到_config.yml<br>创建完成后，在仓库页面，点击绿色的<code>Code</code>按钮，复制仓库的<code>SSH</code>链接，来到你的博客根目录，打开<code>_config.yml</code>，下拉找到如下配置或者自己添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: </span><br><span class="line">  repo: </span><br><span class="line">  branch:</span><br></pre></td></tr></table></figure>
<p>修改成以下样式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">    github: git@github.com:insight-21&#x2F;insight-21.github.io.git</span><br><span class="line">    gitee: git@gitee.com:insight21&#x2F;insight21.git</span><br><span class="line">    coding: git@e.coding.net:insight21&#x2F;insight21-blog&#x2F;insight21.coding.me.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>其中，repo(仓库)下可以配置多个仓库地址，具体格式为<code>自定义名称: 仓库的SSH地址</code>，随后的<code>Gitee</code>、<code>Coding</code>和<code>服务器</code>也是如此配置。<br>接着执行上传命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>上传完成后，刷新页面查看仓库是否变化</p>
</li>
<li><p>在仓库设置中添加个人域名<br>在仓库页面，点击<code>Setting</code>，下拉找到<code>GitHub Pages</code>，在<code>Custom domain</code>中填写你的域名，并且勾选使用<code>HTTPS</code>协议</p>
</li>
</ol>
<ul>
<li><input checked="" disabled="" type="checkbox"> <code>Enforce HTTPS</code></li>
</ul>
<h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><ol>
<li><p>添加SSH公钥<br><a href="#GitHub">与GitHub的步骤相同</a>，在个人账号设置里添加</p>
</li>
<li><p>创建一个<strong>与用户名相同</strong>的仓库<br><a href="https://gitee.com/help/articles/4136" target="_blank" rel="noopener">官方解释</a><br>这样可以创建一个首页访问地址不带二级目录的静态页面</p>
</li>
<li><p>添加仓库地址到_config.yml<br><a href="#GitHub">与GitHub的步骤相同</a></p>
</li>
<li><p>部署静态页面 以及<strong>记得手动更新</strong><br>在仓库页面，点击<code>服务</code>，选择<code>Gitee Pages</code>，选择<code>强制使用HTTPS</code>，点击<code>启动</code>，等待部署完成，即可点击给出的链接访问博客</p>
</li>
</ol>
<h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><blockquote>
<p>Coding自从改版后，很多操作都不同了</p>
</blockquote>
<ol>
<li><p>创建团队、项目和仓库<br>Coding要求你<strong>先创建团队</strong>，然后才能使用各种功能<br>接着创建一个项目，模板选择<code>DevOps</code>，因为只有它能部署静态页面<br>然后在项目页面，左侧选择创建一个代码仓库<br>和前面不同，项目和仓库的名字可以随便取</p>
</li>
<li><p>添加SSH公钥<br><a href="#GitHub">与GitHub的步骤相同</a>，在个人账号设置里添加</p>
</li>
<li><p>添加仓库地址到_config.yml<br><a href="#GitHub">与GitHub的步骤相同</a></p>
</li>
<li><p>部署静态页面<br>在项目页面左侧的<code>持续部署</code>中选择<code>静态网站</code>，需要绑定腾讯云账号，授权、实名认证然后才能部署(因为Coding被马先生全资收购了)<br>这样需要注意一下，<strong>网站的节点选择</strong>，如果选择香港，速度是很慢的，那就失去了部署在国内代码仓库的意义了，因为我们本来就是为了提高速度才来这里的；选择国内节点，绑定个人域名要求域名备案。<br>部署完成后，点击进去可看到静态页面的网站地址。</p>
</li>
</ol>
<h2 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h2><ol>
<li><p>添加SSH公钥<br>我的服务器系统是<code>Ubuntu16.04</code>，公钥保存文件路径为<code>当前用户/.ssh/authorized_keys</code>，其他系统应该差不多，如果没有则自行创建一个，然后把公钥保存进去即可。<br>记得远程连接一下服务器，看看登录是不是不需要用户密码了。</p>
</li>
<li><p>安装Git和Nginx<br>首先更新一下软件源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<p>然后安装<code>git</code>和<code>nginx</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get git</span><br><span class="line">sudo apt-get nginx</span><br></pre></td></tr></table></figure>
<p><code>nginx</code>安装后应该是启动了，命令查看一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service nginx status</span><br></pre></td></tr></table></figure>
<p>如果没有就启动一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建仓库和GitHook</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;home&#x2F;insight&#x2F;gitRepo #新建目录，这是git仓库的位置</span><br><span class="line">sudo mkdir pp &#x2F;home&#x2F;insight&#x2F;www&#x2F;hexo #用于保存nginx的网站文件</span><br><span class="line">cd &#x2F;home&#x2F;insight&#x2F;gitRepo  #转到git仓库的文件夹</span><br><span class="line">sudo git init --bare blog.git #创建一个名叫blog的仓库</span><br><span class="line">sudo vim &#x2F;hooks&#x2F;post-update #创建一个钩子(hook)来实现自动化部署到nginx的网站文件夹</span><br><span class="line">#输入以下内容</span><br><span class="line">rm -rf &#x2F;home&#x2F;insight&#x2F;www&#x2F;hexo</span><br><span class="line">git clone &#x2F;home&#x2F;insight&#x2F;gitRepo&#x2F;blog.git &#x2F;home&#x2F;insight&#x2F;www&#x2F;hexo</span><br></pre></td></tr></table></figure>
<p>不要忘记给钩子<strong>添加可执行权限</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod u+x &#x2F;home&#x2F;insight&#x2F;gitRepo&#x2F;blog.git&#x2F;hooks&#x2F;*</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Nginx配置文件<br>先说明一下，我的系统上，nginx的配置文件的结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf #这是自带的(替身使者)默认配置文件</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;conf.d #这是其他的自定义配置文件</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;sites-enabled #软链接到sites-available</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;sites-available #这才是真正的详细的默认配置</span><br></pre></td></tr></table></figure>
<p>在<code>/etc/nginx/nginx.conf</code>的后半部分可以看到这两句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">include &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;*;</span><br></pre></td></tr></table></figure>
<p>说明其实<code>nginx.conf</code>只是单纯的包含其他配置文件，因此需要去<code>/conf.d</code>下自定义配置文件或者去<code>/sites-available</code>中修改默认配置，在这里我为了省事直接修改默认配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  #默认端口可以不修改</span><br><span class="line">  listen 80 default_server;</span><br><span class="line">  listen [::]:80 default_server;</span><br><span class="line">  #根目录 为前文所创建的网站文件夹</span><br><span class="line">  root &#x2F;home&#x2F;insight&#x2F;www&#x2F;hexo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改完成后，记得检查一下，看是否有错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br><span class="line">nginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful</span><br></pre></td></tr></table></figure>
<p>然后重载一下nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改服务器安全组策略<br>最后别忘记去服务器控制台，修改安全组策略，开放80端口访问博客。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此，自己的博客终于搭建起来啦！</p>
<p>没想到一个博客折腾了我两天（吐血</p>
<p>总的来说，部署到云服务器是最好的选择了，速度快，可以绑定域名，顺带练习Linux命令，真是棒极了呢（苦瓜脸</p>
<p>不过要是GitHub能正常使用，谁会闲得去折腾呢（反正我不会</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title>竞赛模板</title>
    <url>/archives/4279424088/</url>
    <content><![CDATA[<p>竞赛自用模板，放在博客当备份，方便取用。</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pi acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in(x) int (x);cin &gt;&gt; (x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LoopIn(Loop_var) in(Loop_var);while(Loop_var--) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Loop(i, X, N) for(int i = X; i &lt; N; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IOS</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Codes</category>
      </categories>
  </entry>
  <entry>
    <title>常用代码模板</title>
    <url>/archives/3153460496/</url>
    <content><![CDATA[<p>收集各种基础算法的通用模板，持续更新中。</p>
<a id="more"></a>

<p>模板来自AcWing y总。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>最常用的排序，快速排序，属于交换类排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>; <span class="comment">//递归结束条件 划分到只剩下一个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = a[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>; <span class="comment">//选定比较数的方法还有很多</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (a[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j++; <span class="keyword">while</span> (a[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    qSort(a, l, j), qSort(a, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快排日常已经够用了，但也有不能满足需要的时候，比如求逆序对，这个时候就要用到归并排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>; <span class="comment">//递归结束条件 划分到只剩下一个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(a, l, mid);</span><br><span class="line">    mergeSort(a, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> t[N];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//对一分为二的数组 进行比较 然后拷贝到临时数组里面</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;    </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j]) t[index++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> t[index++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个数组可能还有剩余 这时直接把剩下的全拷贝过去</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) t[index++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) t[index++] = a[j++];</span><br><span class="line">    <span class="comment">//最后拷贝已经有序临时数组 </span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) a[i] = t[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>要求已有数据为有序状态。<br>$$</p>
<p>$$<br><strong>整数二分和浮点数二分的区别是</strong></p>
<ol>
<li><p><strong>循环结束条件的写法</strong></p>
</li>
<li><p><strong>浮点数不能使用位运算</strong></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">     mid = (r - l) &gt;&gt; <span class="number">1</span> + l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浮点数 </span></span><br><span class="line"><span class="comment">//因为浮点数会有精度损失问题 所以使用这样的比较写法</span></span><br><span class="line"><span class="comment">//1e-n 保留 n 位小数 保险起见可以多加一位</span></span><br><span class="line"><span class="keyword">while</span> (r - l &lt; <span class="number">1</span>e-n) &#123;</span><br><span class="line">    mid = (r - l) / <span class="number">2.0</span> + l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>划分的区间为 [l, mid]，[mid + 1, r] 时，一般用途求最小化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//划分的区间为[l, mid]，[mid + 1, r]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (r - l) &gt;&gt; <span class="number">1</span> + l; <span class="comment">//防止溢出 好习惯 从我做起</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>划分的区间为 [l, mid - 1]，[mid, r] 时，一般用途求最大化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//划分的区间为[l, mid - 1]，[mid, r]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (r - l + <span class="number">1</span>) &gt;&gt; <span class="number">1</span> + l; <span class="comment">//需要额外加1 防止死循环</span></span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你对区间的划分和对应的二分记不清楚的话，我这里提供一个我自己的小技巧</p>
<ol>
<li>求最大化，右边比左边大，那 mid 就在右区间，而 mid 的左边 mid - 1 就是左区间，即[l, mid - 1]，[mid, r]；</li>
<li>求最小化，左边比右边小，那 mid 就在左区间，而 mid 的右边 mid + 1 就是右区间，即[l, mid]，[mid + 1, r]。</li>
<li>另外，如果只是单纯查找一个数，两个模板都可以用，或者使用最朴素的二分查找。</li>
</ol>
<h2 id="大数加减乘除"><a href="#大数加减乘除" class="headerlink" title="大数加减乘除"></a>大数加减乘除</h2><p>当运算数连 long long 都保存不了，就使用字符串或者整型数组来处理这类问题。</p>
<p>加法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//123 在vector中为321 逆序存放</span></span><br><span class="line"><span class="comment">//&amp; 运算符可以加快传参速度</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用大数 + 小数的方式</span></span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> add(B, A);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//保存加法进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">//不断进行末位相加 结果是余数 进位不断前进</span></span><br><span class="line">        carry += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) carry += B[i];</span><br><span class="line">        ret.push_back(carry % <span class="number">10</span>);</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果最后还有进位 就加进去</span></span><br><span class="line">    <span class="keyword">if</span> (carry) ret.push_back(carry);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>减法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//与加法同理</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        carry = A[i] - carry;<span class="comment">//如果有借位 就减掉</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) carry -= B[i];</span><br><span class="line">        ret.push_back((carry + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//每次借位只有0 或 1两种情况</span></span><br><span class="line">        <span class="keyword">if</span> (carry &lt; <span class="number">0</span>) t = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//消除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (ret.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ret.back() == <span class="number">0</span>) ret.pop_back();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乘法</p>
<ul>
<li><input disabled="" type="checkbox"> 大数和大数乘法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先是大数与一位数的乘法 再扩展到大数与大数的乘法</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mulSingle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        ret.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消除前导0 比如123 可能逆序存放为3210</span></span><br><span class="line">    <span class="keyword">while</span> (ret.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ret.back() == <span class="number">0</span>) ret.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除法</p>
<ul>
<li><input disabled="" type="checkbox"> 大数与大数除法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A 被除数 b 除数 r 余数</span></span><br><span class="line"><span class="comment">//一般情况除数不会爆数据类型 使用普通除法就行</span></span><br><span class="line"><span class="comment">//极限情况的大数与大数除法 需要别的思路 还没有写好...</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div_1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        ret.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (ret.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ret.back() == <span class="number">0</span>) ret.pop_back();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="因数个数与因数之和"><a href="#因数个数与因数之和" class="headerlink" title="因数个数与因数之和"></a>因数个数与因数之和</h2><h3 id="因数个数"><a href="#因数个数" class="headerlink" title="因数个数"></a>因数个数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因数个数</span></span><br><span class="line"><span class="comment">//原理: 每个质因子的最高次方+1的连乘</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>, res = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    Loop(i, <span class="number">2</span>, x) &#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans *= (res + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="因数之和"><a href="#因数之和" class="headerlink" title="因数之和"></a>因数之和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因数之和</span></span><br><span class="line"><span class="comment">//原理: 每个质因子从0次方加到它的最高次方，然后连乘。</span></span><br><span class="line"><span class="comment">//比如：求18 ，（2^0 + 2)*(3^0+3+3^2) = 3*13 = 39 </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>, res = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">    Loop(i, <span class="number">2</span>, x) &#123;</span><br><span class="line">        res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res *= i;</span><br><span class="line">            x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = (res * i - <span class="number">1</span>) / (i - <span class="number">1</span>);</span><br><span class="line">        ans *= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="究极位运算用法收集"><a href="#究极位运算用法收集" class="headerlink" title="究极位运算用法收集"></a>究极位运算用法收集</h2>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>书单</title>
    <url>/archives/3902883597/</url>
    <content><![CDATA[<p>心血来潮想要记录一下个人书单，同时也是一个个人学习路线，挂在博客当达摩克利斯之剑。</p>
 <a id="more"></a> 

<blockquote>
<p>黑色标粗，是想要着重看的；</p>
<p>标号，代表想要阅读的次序。</p>
</blockquote>
<h3 id="计算机基础书籍-面试基础"><a href="#计算机基础书籍-面试基础" class="headerlink" title="计算机基础书籍  |  面试基础"></a>计算机基础书籍  |  面试基础</h3><ol>
<li>数据结构和算法分析 [美] Mark Allen Weiss</li>
<li>操作系统 </li>
<li>计算机组成原理</li>
<li><strong>计算机网络：自顶向下</strong></li>
<li><strong>TCP / IP详解</strong></li>
</ol>
<h3 id="算法和竞赛书籍"><a href="#算法和竞赛书籍" class="headerlink" title="算法和竞赛书籍"></a>算法和竞赛书籍</h3><ol>
<li><strong>算法竞赛入门经典</strong> [中]刘汝佳 （紫 蓝 绿三本书）</li>
<li>算法设计与分析/算法设计手册</li>
<li>挑战程序设计竞赛 [日] 秋叶拓哉  岩田阳一  北川宜稔 <del>（大概率不读）</del></li>
</ol>
<h3 id="Java-基础书籍"><a href="#Java-基础书籍" class="headerlink" title="Java 基础书籍"></a>Java 基础书籍</h3><ol>
<li><strong>Java核心实用技术卷一 、二</strong></li>
<li><strong>Java编程思想 thinking in java</strong></li>
<li><strong>深入理解Java虚拟机</strong></li>
</ol>
<h3 id="JavaEE-开发框架"><a href="#JavaEE-开发框架" class="headerlink" title="JavaEE  |  开发框架"></a>JavaEE  |  开发框架</h3><ol>
<li><strong>Spring Boot 实战</strong> （强烈推荐，目前主流框架）</li>
<li>Spring实战 （学完Spring Boot 回来看Spring）</li>
<li>Spring揭秘</li>
</ol>
<h3 id="Java-提升修炼"><a href="#Java-提升修炼" class="headerlink" title="Java 提升修炼"></a>Java 提升修炼</h3><ol>
<li>Java并发实战</li>
<li>Java并发编程的艺术</li>
<li>OnJava8</li>
<li>Effective Java</li>
<li>重构 改善既有代码设计</li>
<li>函数编程思维</li>
<li>JDK源码阅读</li>
<li>阿里巴巴Java开发手册</li>
</ol>
<h3 id="零食"><a href="#零食" class="headerlink" title="零食"></a>零食</h3><ol>
<li>浪潮之巅</li>
<li>代码整洁之道</li>
<li>程序员的职业素养</li>
</ol>
<p>最后留一句，大学毕业前能看到Spring Boot 算我🐂🍺。</p>
]]></content>
      <categories>
        <category>Books</category>
      </categories>
  </entry>
  <entry>
    <title>My First archive</title>
    <url>/archives/2043672006/</url>
    <content><![CDATA[<p>文章测试</p>
<p>$$<br>\pi = \frac a b<br>$$</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
</search>
